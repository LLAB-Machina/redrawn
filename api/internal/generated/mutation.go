// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"redrawn/api/internal/generated/album"
	"redrawn/api/internal/generated/albuminvite"
	"redrawn/api/internal/generated/albuminvitelink"
	"redrawn/api/internal/generated/albumpassword"
	"redrawn/api/internal/generated/albumuser"
	"redrawn/api/internal/generated/creditusage"
	"redrawn/api/internal/generated/file"
	"redrawn/api/internal/generated/generatedphoto"
	"redrawn/api/internal/generated/originalphoto"
	"redrawn/api/internal/generated/predicate"
	"redrawn/api/internal/generated/price"
	"redrawn/api/internal/generated/purchase"
	"redrawn/api/internal/generated/theme"
	"redrawn/api/internal/generated/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum           = "Album"
	TypeAlbumInvite     = "AlbumInvite"
	TypeAlbumInviteLink = "AlbumInviteLink"
	TypeAlbumPassword   = "AlbumPassword"
	TypeAlbumUser       = "AlbumUser"
	TypeCreditUsage     = "CreditUsage"
	TypeFile            = "File"
	TypeGeneratedPhoto  = "GeneratedPhoto"
	TypeOriginalPhoto   = "OriginalPhoto"
	TypePrice           = "Price"
	TypePurchase        = "Purchase"
	TypeTheme           = "Theme"
	TypeUser            = "User"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	name                   *string
	slug                   *string
	description            *string
	visibility             *album.Visibility
	originals_visible_to   *album.OriginalsVisibleTo
	clearedFields          map[string]struct{}
	created_by             *string
	clearedcreated_by      bool
	default_theme          *string
	cleareddefault_theme   bool
	members                map[int]struct{}
	removedmembers         map[int]struct{}
	clearedmembers         bool
	original_photos        map[string]struct{}
	removedoriginal_photos map[string]struct{}
	clearedoriginal_photos bool
	invite_links           map[string]struct{}
	removedinvite_links    map[string]struct{}
	clearedinvite_links    bool
	email_invites          map[string]struct{}
	removedemail_invites   map[string]struct{}
	clearedemail_invites   bool
	passwords              map[string]struct{}
	removedpasswords       map[string]struct{}
	clearedpasswords       bool
	done                   bool
	oldValue               func(context.Context) (*Album, error)
	predicates             []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id string) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Album entities.
func (m *AlbumMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlbumMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlbumMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlbumMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[album.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlbumMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[album.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlbumMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, album.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AlbumMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *AlbumMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *AlbumMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *AlbumMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *AlbumMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlbumMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlbumMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[album.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlbumMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[album.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlbumMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, album.FieldDescription)
}

// SetVisibility sets the "visibility" field.
func (m *AlbumMutation) SetVisibility(a album.Visibility) {
	m.visibility = &a
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *AlbumMutation) Visibility() (r album.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldVisibility(ctx context.Context) (v album.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *AlbumMutation) ResetVisibility() {
	m.visibility = nil
}

// SetOriginalsVisibleTo sets the "originals_visible_to" field.
func (m *AlbumMutation) SetOriginalsVisibleTo(avt album.OriginalsVisibleTo) {
	m.originals_visible_to = &avt
}

// OriginalsVisibleTo returns the value of the "originals_visible_to" field in the mutation.
func (m *AlbumMutation) OriginalsVisibleTo() (r album.OriginalsVisibleTo, exists bool) {
	v := m.originals_visible_to
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalsVisibleTo returns the old "originals_visible_to" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldOriginalsVisibleTo(ctx context.Context) (v album.OriginalsVisibleTo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalsVisibleTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalsVisibleTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalsVisibleTo: %w", err)
	}
	return oldValue.OriginalsVisibleTo, nil
}

// ResetOriginalsVisibleTo resets all changes to the "originals_visible_to" field.
func (m *AlbumMutation) ResetOriginalsVisibleTo() {
	m.originals_visible_to = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *AlbumMutation) SetCreatedByID(id string) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *AlbumMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *AlbumMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *AlbumMutation) CreatedByID() (id string, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *AlbumMutation) CreatedByIDs() (ids []string) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *AlbumMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetDefaultThemeID sets the "default_theme" edge to the Theme entity by id.
func (m *AlbumMutation) SetDefaultThemeID(id string) {
	m.default_theme = &id
}

// ClearDefaultTheme clears the "default_theme" edge to the Theme entity.
func (m *AlbumMutation) ClearDefaultTheme() {
	m.cleareddefault_theme = true
}

// DefaultThemeCleared reports if the "default_theme" edge to the Theme entity was cleared.
func (m *AlbumMutation) DefaultThemeCleared() bool {
	return m.cleareddefault_theme
}

// DefaultThemeID returns the "default_theme" edge ID in the mutation.
func (m *AlbumMutation) DefaultThemeID() (id string, exists bool) {
	if m.default_theme != nil {
		return *m.default_theme, true
	}
	return
}

// DefaultThemeIDs returns the "default_theme" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultThemeID instead. It exists only for internal usage by the builders.
func (m *AlbumMutation) DefaultThemeIDs() (ids []string) {
	if id := m.default_theme; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultTheme resets all changes to the "default_theme" edge.
func (m *AlbumMutation) ResetDefaultTheme() {
	m.default_theme = nil
	m.cleareddefault_theme = false
}

// AddMemberIDs adds the "members" edge to the AlbumUser entity by ids.
func (m *AlbumMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the AlbumUser entity.
func (m *AlbumMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the AlbumUser entity was cleared.
func (m *AlbumMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the AlbumUser entity by IDs.
func (m *AlbumMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the AlbumUser entity.
func (m *AlbumMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *AlbumMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *AlbumMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddOriginalPhotoIDs adds the "original_photos" edge to the OriginalPhoto entity by ids.
func (m *AlbumMutation) AddOriginalPhotoIDs(ids ...string) {
	if m.original_photos == nil {
		m.original_photos = make(map[string]struct{})
	}
	for i := range ids {
		m.original_photos[ids[i]] = struct{}{}
	}
}

// ClearOriginalPhotos clears the "original_photos" edge to the OriginalPhoto entity.
func (m *AlbumMutation) ClearOriginalPhotos() {
	m.clearedoriginal_photos = true
}

// OriginalPhotosCleared reports if the "original_photos" edge to the OriginalPhoto entity was cleared.
func (m *AlbumMutation) OriginalPhotosCleared() bool {
	return m.clearedoriginal_photos
}

// RemoveOriginalPhotoIDs removes the "original_photos" edge to the OriginalPhoto entity by IDs.
func (m *AlbumMutation) RemoveOriginalPhotoIDs(ids ...string) {
	if m.removedoriginal_photos == nil {
		m.removedoriginal_photos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.original_photos, ids[i])
		m.removedoriginal_photos[ids[i]] = struct{}{}
	}
}

// RemovedOriginalPhotos returns the removed IDs of the "original_photos" edge to the OriginalPhoto entity.
func (m *AlbumMutation) RemovedOriginalPhotosIDs() (ids []string) {
	for id := range m.removedoriginal_photos {
		ids = append(ids, id)
	}
	return
}

// OriginalPhotosIDs returns the "original_photos" edge IDs in the mutation.
func (m *AlbumMutation) OriginalPhotosIDs() (ids []string) {
	for id := range m.original_photos {
		ids = append(ids, id)
	}
	return
}

// ResetOriginalPhotos resets all changes to the "original_photos" edge.
func (m *AlbumMutation) ResetOriginalPhotos() {
	m.original_photos = nil
	m.clearedoriginal_photos = false
	m.removedoriginal_photos = nil
}

// AddInviteLinkIDs adds the "invite_links" edge to the AlbumInviteLink entity by ids.
func (m *AlbumMutation) AddInviteLinkIDs(ids ...string) {
	if m.invite_links == nil {
		m.invite_links = make(map[string]struct{})
	}
	for i := range ids {
		m.invite_links[ids[i]] = struct{}{}
	}
}

// ClearInviteLinks clears the "invite_links" edge to the AlbumInviteLink entity.
func (m *AlbumMutation) ClearInviteLinks() {
	m.clearedinvite_links = true
}

// InviteLinksCleared reports if the "invite_links" edge to the AlbumInviteLink entity was cleared.
func (m *AlbumMutation) InviteLinksCleared() bool {
	return m.clearedinvite_links
}

// RemoveInviteLinkIDs removes the "invite_links" edge to the AlbumInviteLink entity by IDs.
func (m *AlbumMutation) RemoveInviteLinkIDs(ids ...string) {
	if m.removedinvite_links == nil {
		m.removedinvite_links = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.invite_links, ids[i])
		m.removedinvite_links[ids[i]] = struct{}{}
	}
}

// RemovedInviteLinks returns the removed IDs of the "invite_links" edge to the AlbumInviteLink entity.
func (m *AlbumMutation) RemovedInviteLinksIDs() (ids []string) {
	for id := range m.removedinvite_links {
		ids = append(ids, id)
	}
	return
}

// InviteLinksIDs returns the "invite_links" edge IDs in the mutation.
func (m *AlbumMutation) InviteLinksIDs() (ids []string) {
	for id := range m.invite_links {
		ids = append(ids, id)
	}
	return
}

// ResetInviteLinks resets all changes to the "invite_links" edge.
func (m *AlbumMutation) ResetInviteLinks() {
	m.invite_links = nil
	m.clearedinvite_links = false
	m.removedinvite_links = nil
}

// AddEmailInviteIDs adds the "email_invites" edge to the AlbumInvite entity by ids.
func (m *AlbumMutation) AddEmailInviteIDs(ids ...string) {
	if m.email_invites == nil {
		m.email_invites = make(map[string]struct{})
	}
	for i := range ids {
		m.email_invites[ids[i]] = struct{}{}
	}
}

// ClearEmailInvites clears the "email_invites" edge to the AlbumInvite entity.
func (m *AlbumMutation) ClearEmailInvites() {
	m.clearedemail_invites = true
}

// EmailInvitesCleared reports if the "email_invites" edge to the AlbumInvite entity was cleared.
func (m *AlbumMutation) EmailInvitesCleared() bool {
	return m.clearedemail_invites
}

// RemoveEmailInviteIDs removes the "email_invites" edge to the AlbumInvite entity by IDs.
func (m *AlbumMutation) RemoveEmailInviteIDs(ids ...string) {
	if m.removedemail_invites == nil {
		m.removedemail_invites = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.email_invites, ids[i])
		m.removedemail_invites[ids[i]] = struct{}{}
	}
}

// RemovedEmailInvites returns the removed IDs of the "email_invites" edge to the AlbumInvite entity.
func (m *AlbumMutation) RemovedEmailInvitesIDs() (ids []string) {
	for id := range m.removedemail_invites {
		ids = append(ids, id)
	}
	return
}

// EmailInvitesIDs returns the "email_invites" edge IDs in the mutation.
func (m *AlbumMutation) EmailInvitesIDs() (ids []string) {
	for id := range m.email_invites {
		ids = append(ids, id)
	}
	return
}

// ResetEmailInvites resets all changes to the "email_invites" edge.
func (m *AlbumMutation) ResetEmailInvites() {
	m.email_invites = nil
	m.clearedemail_invites = false
	m.removedemail_invites = nil
}

// AddPasswordIDs adds the "passwords" edge to the AlbumPassword entity by ids.
func (m *AlbumMutation) AddPasswordIDs(ids ...string) {
	if m.passwords == nil {
		m.passwords = make(map[string]struct{})
	}
	for i := range ids {
		m.passwords[ids[i]] = struct{}{}
	}
}

// ClearPasswords clears the "passwords" edge to the AlbumPassword entity.
func (m *AlbumMutation) ClearPasswords() {
	m.clearedpasswords = true
}

// PasswordsCleared reports if the "passwords" edge to the AlbumPassword entity was cleared.
func (m *AlbumMutation) PasswordsCleared() bool {
	return m.clearedpasswords
}

// RemovePasswordIDs removes the "passwords" edge to the AlbumPassword entity by IDs.
func (m *AlbumMutation) RemovePasswordIDs(ids ...string) {
	if m.removedpasswords == nil {
		m.removedpasswords = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.passwords, ids[i])
		m.removedpasswords[ids[i]] = struct{}{}
	}
}

// RemovedPasswords returns the removed IDs of the "passwords" edge to the AlbumPassword entity.
func (m *AlbumMutation) RemovedPasswordsIDs() (ids []string) {
	for id := range m.removedpasswords {
		ids = append(ids, id)
	}
	return
}

// PasswordsIDs returns the "passwords" edge IDs in the mutation.
func (m *AlbumMutation) PasswordsIDs() (ids []string) {
	for id := range m.passwords {
		ids = append(ids, id)
	}
	return
}

// ResetPasswords resets all changes to the "passwords" edge.
func (m *AlbumMutation) ResetPasswords() {
	m.passwords = nil
	m.clearedpasswords = false
	m.removedpasswords = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Album, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, album.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, album.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, album.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, album.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, album.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, album.FieldDescription)
	}
	if m.visibility != nil {
		fields = append(fields, album.FieldVisibility)
	}
	if m.originals_visible_to != nil {
		fields = append(fields, album.FieldOriginalsVisibleTo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldCreatedAt:
		return m.CreatedAt()
	case album.FieldUpdatedAt:
		return m.UpdatedAt()
	case album.FieldDeletedAt:
		return m.DeletedAt()
	case album.FieldName:
		return m.Name()
	case album.FieldSlug:
		return m.Slug()
	case album.FieldDescription:
		return m.Description()
	case album.FieldVisibility:
		return m.Visibility()
	case album.FieldOriginalsVisibleTo:
		return m.OriginalsVisibleTo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case album.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case album.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case album.FieldName:
		return m.OldName(ctx)
	case album.FieldSlug:
		return m.OldSlug(ctx)
	case album.FieldDescription:
		return m.OldDescription(ctx)
	case album.FieldVisibility:
		return m.OldVisibility(ctx)
	case album.FieldOriginalsVisibleTo:
		return m.OldOriginalsVisibleTo(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case album.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case album.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case album.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case album.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case album.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case album.FieldVisibility:
		v, ok := value.(album.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case album.FieldOriginalsVisibleTo:
		v, ok := value.(album.OriginalsVisibleTo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalsVisibleTo(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(album.FieldDeletedAt) {
		fields = append(fields, album.FieldDeletedAt)
	}
	if m.FieldCleared(album.FieldDescription) {
		fields = append(fields, album.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	switch name {
	case album.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case album.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case album.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case album.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case album.FieldName:
		m.ResetName()
		return nil
	case album.FieldSlug:
		m.ResetSlug()
		return nil
	case album.FieldDescription:
		m.ResetDescription()
		return nil
	case album.FieldVisibility:
		m.ResetVisibility()
		return nil
	case album.FieldOriginalsVisibleTo:
		m.ResetOriginalsVisibleTo()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.created_by != nil {
		edges = append(edges, album.EdgeCreatedBy)
	}
	if m.default_theme != nil {
		edges = append(edges, album.EdgeDefaultTheme)
	}
	if m.members != nil {
		edges = append(edges, album.EdgeMembers)
	}
	if m.original_photos != nil {
		edges = append(edges, album.EdgeOriginalPhotos)
	}
	if m.invite_links != nil {
		edges = append(edges, album.EdgeInviteLinks)
	}
	if m.email_invites != nil {
		edges = append(edges, album.EdgeEmailInvites)
	}
	if m.passwords != nil {
		edges = append(edges, album.EdgePasswords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case album.EdgeDefaultTheme:
		if id := m.default_theme; id != nil {
			return []ent.Value{*id}
		}
	case album.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeOriginalPhotos:
		ids := make([]ent.Value, 0, len(m.original_photos))
		for id := range m.original_photos {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeInviteLinks:
		ids := make([]ent.Value, 0, len(m.invite_links))
		for id := range m.invite_links {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeEmailInvites:
		ids := make([]ent.Value, 0, len(m.email_invites))
		for id := range m.email_invites {
			ids = append(ids, id)
		}
		return ids
	case album.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.passwords))
		for id := range m.passwords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmembers != nil {
		edges = append(edges, album.EdgeMembers)
	}
	if m.removedoriginal_photos != nil {
		edges = append(edges, album.EdgeOriginalPhotos)
	}
	if m.removedinvite_links != nil {
		edges = append(edges, album.EdgeInviteLinks)
	}
	if m.removedemail_invites != nil {
		edges = append(edges, album.EdgeEmailInvites)
	}
	if m.removedpasswords != nil {
		edges = append(edges, album.EdgePasswords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeOriginalPhotos:
		ids := make([]ent.Value, 0, len(m.removedoriginal_photos))
		for id := range m.removedoriginal_photos {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeInviteLinks:
		ids := make([]ent.Value, 0, len(m.removedinvite_links))
		for id := range m.removedinvite_links {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeEmailInvites:
		ids := make([]ent.Value, 0, len(m.removedemail_invites))
		for id := range m.removedemail_invites {
			ids = append(ids, id)
		}
		return ids
	case album.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.removedpasswords))
		for id := range m.removedpasswords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcreated_by {
		edges = append(edges, album.EdgeCreatedBy)
	}
	if m.cleareddefault_theme {
		edges = append(edges, album.EdgeDefaultTheme)
	}
	if m.clearedmembers {
		edges = append(edges, album.EdgeMembers)
	}
	if m.clearedoriginal_photos {
		edges = append(edges, album.EdgeOriginalPhotos)
	}
	if m.clearedinvite_links {
		edges = append(edges, album.EdgeInviteLinks)
	}
	if m.clearedemail_invites {
		edges = append(edges, album.EdgeEmailInvites)
	}
	if m.clearedpasswords {
		edges = append(edges, album.EdgePasswords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	switch name {
	case album.EdgeCreatedBy:
		return m.clearedcreated_by
	case album.EdgeDefaultTheme:
		return m.cleareddefault_theme
	case album.EdgeMembers:
		return m.clearedmembers
	case album.EdgeOriginalPhotos:
		return m.clearedoriginal_photos
	case album.EdgeInviteLinks:
		return m.clearedinvite_links
	case album.EdgeEmailInvites:
		return m.clearedemail_invites
	case album.EdgePasswords:
		return m.clearedpasswords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	switch name {
	case album.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case album.EdgeDefaultTheme:
		m.ClearDefaultTheme()
		return nil
	}
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	switch name {
	case album.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case album.EdgeDefaultTheme:
		m.ResetDefaultTheme()
		return nil
	case album.EdgeMembers:
		m.ResetMembers()
		return nil
	case album.EdgeOriginalPhotos:
		m.ResetOriginalPhotos()
		return nil
	case album.EdgeInviteLinks:
		m.ResetInviteLinks()
		return nil
	case album.EdgeEmailInvites:
		m.ResetEmailInvites()
		return nil
	case album.EdgePasswords:
		m.ResetPasswords()
		return nil
	}
	return fmt.Errorf("unknown Album edge %s", name)
}

// AlbumInviteMutation represents an operation that mutates the AlbumInvite nodes in the graph.
type AlbumInviteMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	email              *string
	role               *albuminvite.Role
	status             *albuminvite.Status
	token              *string
	expires_at         *time.Time
	revoked_at         *time.Time
	accepted_at        *time.Time
	clearedFields      map[string]struct{}
	album              *string
	clearedalbum       bool
	created_by         *string
	clearedcreated_by  bool
	accepted_by        *string
	clearedaccepted_by bool
	done               bool
	oldValue           func(context.Context) (*AlbumInvite, error)
	predicates         []predicate.AlbumInvite
}

var _ ent.Mutation = (*AlbumInviteMutation)(nil)

// albuminviteOption allows management of the mutation configuration using functional options.
type albuminviteOption func(*AlbumInviteMutation)

// newAlbumInviteMutation creates new mutation for the AlbumInvite entity.
func newAlbumInviteMutation(c config, op Op, opts ...albuminviteOption) *AlbumInviteMutation {
	m := &AlbumInviteMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbumInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumInviteID sets the ID field of the mutation.
func withAlbumInviteID(id string) albuminviteOption {
	return func(m *AlbumInviteMutation) {
		var (
			err   error
			once  sync.Once
			value *AlbumInvite
		)
		m.oldValue = func(ctx context.Context) (*AlbumInvite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlbumInvite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbumInvite sets the old AlbumInvite of the mutation.
func withAlbumInvite(node *AlbumInvite) albuminviteOption {
	return func(m *AlbumInviteMutation) {
		m.oldValue = func(context.Context) (*AlbumInvite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumInviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumInviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlbumInvite entities.
func (m *AlbumInviteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumInviteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumInviteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlbumInvite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumInviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumInviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumInviteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumInviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumInviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumInviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *AlbumInviteMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AlbumInviteMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AlbumInviteMutation) ResetEmail() {
	m.email = nil
}

// SetRole sets the "role" field.
func (m *AlbumInviteMutation) SetRole(a albuminvite.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AlbumInviteMutation) Role() (r albuminvite.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldRole(ctx context.Context) (v albuminvite.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AlbumInviteMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *AlbumInviteMutation) SetStatus(a albuminvite.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AlbumInviteMutation) Status() (r albuminvite.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldStatus(ctx context.Context) (v albuminvite.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AlbumInviteMutation) ResetStatus() {
	m.status = nil
}

// SetToken sets the "token" field.
func (m *AlbumInviteMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AlbumInviteMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AlbumInviteMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AlbumInviteMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AlbumInviteMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AlbumInviteMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[albuminvite.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AlbumInviteMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[albuminvite.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AlbumInviteMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, albuminvite.FieldExpiresAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *AlbumInviteMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *AlbumInviteMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *AlbumInviteMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[albuminvite.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *AlbumInviteMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[albuminvite.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *AlbumInviteMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, albuminvite.FieldRevokedAt)
}

// SetAcceptedAt sets the "accepted_at" field.
func (m *AlbumInviteMutation) SetAcceptedAt(t time.Time) {
	m.accepted_at = &t
}

// AcceptedAt returns the value of the "accepted_at" field in the mutation.
func (m *AlbumInviteMutation) AcceptedAt() (r time.Time, exists bool) {
	v := m.accepted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAt returns the old "accepted_at" field's value of the AlbumInvite entity.
// If the AlbumInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteMutation) OldAcceptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAt: %w", err)
	}
	return oldValue.AcceptedAt, nil
}

// ClearAcceptedAt clears the value of the "accepted_at" field.
func (m *AlbumInviteMutation) ClearAcceptedAt() {
	m.accepted_at = nil
	m.clearedFields[albuminvite.FieldAcceptedAt] = struct{}{}
}

// AcceptedAtCleared returns if the "accepted_at" field was cleared in this mutation.
func (m *AlbumInviteMutation) AcceptedAtCleared() bool {
	_, ok := m.clearedFields[albuminvite.FieldAcceptedAt]
	return ok
}

// ResetAcceptedAt resets all changes to the "accepted_at" field.
func (m *AlbumInviteMutation) ResetAcceptedAt() {
	m.accepted_at = nil
	delete(m.clearedFields, albuminvite.FieldAcceptedAt)
}

// SetAlbumID sets the "album" edge to the Album entity by id.
func (m *AlbumInviteMutation) SetAlbumID(id string) {
	m.album = &id
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *AlbumInviteMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *AlbumInviteMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// AlbumID returns the "album" edge ID in the mutation.
func (m *AlbumInviteMutation) AlbumID() (id string, exists bool) {
	if m.album != nil {
		return *m.album, true
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlbumID instead. It exists only for internal usage by the builders.
func (m *AlbumInviteMutation) AlbumIDs() (ids []string) {
	if id := m.album; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *AlbumInviteMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *AlbumInviteMutation) SetCreatedByID(id string) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *AlbumInviteMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *AlbumInviteMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *AlbumInviteMutation) CreatedByID() (id string, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *AlbumInviteMutation) CreatedByIDs() (ids []string) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *AlbumInviteMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetAcceptedByID sets the "accepted_by" edge to the User entity by id.
func (m *AlbumInviteMutation) SetAcceptedByID(id string) {
	m.accepted_by = &id
}

// ClearAcceptedBy clears the "accepted_by" edge to the User entity.
func (m *AlbumInviteMutation) ClearAcceptedBy() {
	m.clearedaccepted_by = true
}

// AcceptedByCleared reports if the "accepted_by" edge to the User entity was cleared.
func (m *AlbumInviteMutation) AcceptedByCleared() bool {
	return m.clearedaccepted_by
}

// AcceptedByID returns the "accepted_by" edge ID in the mutation.
func (m *AlbumInviteMutation) AcceptedByID() (id string, exists bool) {
	if m.accepted_by != nil {
		return *m.accepted_by, true
	}
	return
}

// AcceptedByIDs returns the "accepted_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AcceptedByID instead. It exists only for internal usage by the builders.
func (m *AlbumInviteMutation) AcceptedByIDs() (ids []string) {
	if id := m.accepted_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAcceptedBy resets all changes to the "accepted_by" edge.
func (m *AlbumInviteMutation) ResetAcceptedBy() {
	m.accepted_by = nil
	m.clearedaccepted_by = false
}

// Where appends a list predicates to the AlbumInviteMutation builder.
func (m *AlbumInviteMutation) Where(ps ...predicate.AlbumInvite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumInviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumInviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlbumInvite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumInviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumInviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlbumInvite).
func (m *AlbumInviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumInviteMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, albuminvite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, albuminvite.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, albuminvite.FieldEmail)
	}
	if m.role != nil {
		fields = append(fields, albuminvite.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, albuminvite.FieldStatus)
	}
	if m.token != nil {
		fields = append(fields, albuminvite.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, albuminvite.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, albuminvite.FieldRevokedAt)
	}
	if m.accepted_at != nil {
		fields = append(fields, albuminvite.FieldAcceptedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumInviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case albuminvite.FieldCreatedAt:
		return m.CreatedAt()
	case albuminvite.FieldUpdatedAt:
		return m.UpdatedAt()
	case albuminvite.FieldEmail:
		return m.Email()
	case albuminvite.FieldRole:
		return m.Role()
	case albuminvite.FieldStatus:
		return m.Status()
	case albuminvite.FieldToken:
		return m.Token()
	case albuminvite.FieldExpiresAt:
		return m.ExpiresAt()
	case albuminvite.FieldRevokedAt:
		return m.RevokedAt()
	case albuminvite.FieldAcceptedAt:
		return m.AcceptedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumInviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case albuminvite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case albuminvite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case albuminvite.FieldEmail:
		return m.OldEmail(ctx)
	case albuminvite.FieldRole:
		return m.OldRole(ctx)
	case albuminvite.FieldStatus:
		return m.OldStatus(ctx)
	case albuminvite.FieldToken:
		return m.OldToken(ctx)
	case albuminvite.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case albuminvite.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case albuminvite.FieldAcceptedAt:
		return m.OldAcceptedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlbumInvite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumInviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case albuminvite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case albuminvite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case albuminvite.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case albuminvite.FieldRole:
		v, ok := value.(albuminvite.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case albuminvite.FieldStatus:
		v, ok := value.(albuminvite.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case albuminvite.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case albuminvite.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case albuminvite.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case albuminvite.FieldAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumInvite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumInviteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumInviteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumInviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlbumInvite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumInviteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(albuminvite.FieldExpiresAt) {
		fields = append(fields, albuminvite.FieldExpiresAt)
	}
	if m.FieldCleared(albuminvite.FieldRevokedAt) {
		fields = append(fields, albuminvite.FieldRevokedAt)
	}
	if m.FieldCleared(albuminvite.FieldAcceptedAt) {
		fields = append(fields, albuminvite.FieldAcceptedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumInviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumInviteMutation) ClearField(name string) error {
	switch name {
	case albuminvite.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case albuminvite.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case albuminvite.FieldAcceptedAt:
		m.ClearAcceptedAt()
		return nil
	}
	return fmt.Errorf("unknown AlbumInvite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumInviteMutation) ResetField(name string) error {
	switch name {
	case albuminvite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case albuminvite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case albuminvite.FieldEmail:
		m.ResetEmail()
		return nil
	case albuminvite.FieldRole:
		m.ResetRole()
		return nil
	case albuminvite.FieldStatus:
		m.ResetStatus()
		return nil
	case albuminvite.FieldToken:
		m.ResetToken()
		return nil
	case albuminvite.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case albuminvite.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case albuminvite.FieldAcceptedAt:
		m.ResetAcceptedAt()
		return nil
	}
	return fmt.Errorf("unknown AlbumInvite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumInviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.album != nil {
		edges = append(edges, albuminvite.EdgeAlbum)
	}
	if m.created_by != nil {
		edges = append(edges, albuminvite.EdgeCreatedBy)
	}
	if m.accepted_by != nil {
		edges = append(edges, albuminvite.EdgeAcceptedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumInviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case albuminvite.EdgeAlbum:
		if id := m.album; id != nil {
			return []ent.Value{*id}
		}
	case albuminvite.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case albuminvite.EdgeAcceptedBy:
		if id := m.accepted_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumInviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumInviteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumInviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedalbum {
		edges = append(edges, albuminvite.EdgeAlbum)
	}
	if m.clearedcreated_by {
		edges = append(edges, albuminvite.EdgeCreatedBy)
	}
	if m.clearedaccepted_by {
		edges = append(edges, albuminvite.EdgeAcceptedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumInviteMutation) EdgeCleared(name string) bool {
	switch name {
	case albuminvite.EdgeAlbum:
		return m.clearedalbum
	case albuminvite.EdgeCreatedBy:
		return m.clearedcreated_by
	case albuminvite.EdgeAcceptedBy:
		return m.clearedaccepted_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumInviteMutation) ClearEdge(name string) error {
	switch name {
	case albuminvite.EdgeAlbum:
		m.ClearAlbum()
		return nil
	case albuminvite.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case albuminvite.EdgeAcceptedBy:
		m.ClearAcceptedBy()
		return nil
	}
	return fmt.Errorf("unknown AlbumInvite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumInviteMutation) ResetEdge(name string) error {
	switch name {
	case albuminvite.EdgeAlbum:
		m.ResetAlbum()
		return nil
	case albuminvite.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case albuminvite.EdgeAcceptedBy:
		m.ResetAcceptedBy()
		return nil
	}
	return fmt.Errorf("unknown AlbumInvite edge %s", name)
}

// AlbumInviteLinkMutation represents an operation that mutates the AlbumInviteLink nodes in the graph.
type AlbumInviteLinkMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	token             *string
	role              *albuminvitelink.Role
	max_uses          *int
	addmax_uses       *int
	uses              *int
	adduses           *int
	expires_at        *time.Time
	revoked_at        *time.Time
	clearedFields     map[string]struct{}
	album             *string
	clearedalbum      bool
	created_by        *string
	clearedcreated_by bool
	revoked_by        *string
	clearedrevoked_by bool
	done              bool
	oldValue          func(context.Context) (*AlbumInviteLink, error)
	predicates        []predicate.AlbumInviteLink
}

var _ ent.Mutation = (*AlbumInviteLinkMutation)(nil)

// albuminvitelinkOption allows management of the mutation configuration using functional options.
type albuminvitelinkOption func(*AlbumInviteLinkMutation)

// newAlbumInviteLinkMutation creates new mutation for the AlbumInviteLink entity.
func newAlbumInviteLinkMutation(c config, op Op, opts ...albuminvitelinkOption) *AlbumInviteLinkMutation {
	m := &AlbumInviteLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbumInviteLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumInviteLinkID sets the ID field of the mutation.
func withAlbumInviteLinkID(id string) albuminvitelinkOption {
	return func(m *AlbumInviteLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *AlbumInviteLink
		)
		m.oldValue = func(ctx context.Context) (*AlbumInviteLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlbumInviteLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbumInviteLink sets the old AlbumInviteLink of the mutation.
func withAlbumInviteLink(node *AlbumInviteLink) albuminvitelinkOption {
	return func(m *AlbumInviteLinkMutation) {
		m.oldValue = func(context.Context) (*AlbumInviteLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumInviteLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumInviteLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlbumInviteLink entities.
func (m *AlbumInviteLinkMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumInviteLinkMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumInviteLinkMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlbumInviteLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumInviteLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumInviteLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumInviteLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumInviteLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumInviteLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumInviteLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *AlbumInviteLinkMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AlbumInviteLinkMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AlbumInviteLinkMutation) ResetToken() {
	m.token = nil
}

// SetRole sets the "role" field.
func (m *AlbumInviteLinkMutation) SetRole(a albuminvitelink.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AlbumInviteLinkMutation) Role() (r albuminvitelink.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldRole(ctx context.Context) (v albuminvitelink.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AlbumInviteLinkMutation) ResetRole() {
	m.role = nil
}

// SetMaxUses sets the "max_uses" field.
func (m *AlbumInviteLinkMutation) SetMaxUses(i int) {
	m.max_uses = &i
	m.addmax_uses = nil
}

// MaxUses returns the value of the "max_uses" field in the mutation.
func (m *AlbumInviteLinkMutation) MaxUses() (r int, exists bool) {
	v := m.max_uses
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUses returns the old "max_uses" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldMaxUses(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUses: %w", err)
	}
	return oldValue.MaxUses, nil
}

// AddMaxUses adds i to the "max_uses" field.
func (m *AlbumInviteLinkMutation) AddMaxUses(i int) {
	if m.addmax_uses != nil {
		*m.addmax_uses += i
	} else {
		m.addmax_uses = &i
	}
}

// AddedMaxUses returns the value that was added to the "max_uses" field in this mutation.
func (m *AlbumInviteLinkMutation) AddedMaxUses() (r int, exists bool) {
	v := m.addmax_uses
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxUses clears the value of the "max_uses" field.
func (m *AlbumInviteLinkMutation) ClearMaxUses() {
	m.max_uses = nil
	m.addmax_uses = nil
	m.clearedFields[albuminvitelink.FieldMaxUses] = struct{}{}
}

// MaxUsesCleared returns if the "max_uses" field was cleared in this mutation.
func (m *AlbumInviteLinkMutation) MaxUsesCleared() bool {
	_, ok := m.clearedFields[albuminvitelink.FieldMaxUses]
	return ok
}

// ResetMaxUses resets all changes to the "max_uses" field.
func (m *AlbumInviteLinkMutation) ResetMaxUses() {
	m.max_uses = nil
	m.addmax_uses = nil
	delete(m.clearedFields, albuminvitelink.FieldMaxUses)
}

// SetUses sets the "uses" field.
func (m *AlbumInviteLinkMutation) SetUses(i int) {
	m.uses = &i
	m.adduses = nil
}

// Uses returns the value of the "uses" field in the mutation.
func (m *AlbumInviteLinkMutation) Uses() (r int, exists bool) {
	v := m.uses
	if v == nil {
		return
	}
	return *v, true
}

// OldUses returns the old "uses" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldUses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUses: %w", err)
	}
	return oldValue.Uses, nil
}

// AddUses adds i to the "uses" field.
func (m *AlbumInviteLinkMutation) AddUses(i int) {
	if m.adduses != nil {
		*m.adduses += i
	} else {
		m.adduses = &i
	}
}

// AddedUses returns the value that was added to the "uses" field in this mutation.
func (m *AlbumInviteLinkMutation) AddedUses() (r int, exists bool) {
	v := m.adduses
	if v == nil {
		return
	}
	return *v, true
}

// ResetUses resets all changes to the "uses" field.
func (m *AlbumInviteLinkMutation) ResetUses() {
	m.uses = nil
	m.adduses = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AlbumInviteLinkMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AlbumInviteLinkMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AlbumInviteLinkMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[albuminvitelink.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AlbumInviteLinkMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[albuminvitelink.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AlbumInviteLinkMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, albuminvitelink.FieldExpiresAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *AlbumInviteLinkMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *AlbumInviteLinkMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the AlbumInviteLink entity.
// If the AlbumInviteLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumInviteLinkMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *AlbumInviteLinkMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[albuminvitelink.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *AlbumInviteLinkMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[albuminvitelink.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *AlbumInviteLinkMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, albuminvitelink.FieldRevokedAt)
}

// SetAlbumID sets the "album" edge to the Album entity by id.
func (m *AlbumInviteLinkMutation) SetAlbumID(id string) {
	m.album = &id
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *AlbumInviteLinkMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *AlbumInviteLinkMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// AlbumID returns the "album" edge ID in the mutation.
func (m *AlbumInviteLinkMutation) AlbumID() (id string, exists bool) {
	if m.album != nil {
		return *m.album, true
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlbumID instead. It exists only for internal usage by the builders.
func (m *AlbumInviteLinkMutation) AlbumIDs() (ids []string) {
	if id := m.album; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *AlbumInviteLinkMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *AlbumInviteLinkMutation) SetCreatedByID(id string) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *AlbumInviteLinkMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *AlbumInviteLinkMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *AlbumInviteLinkMutation) CreatedByID() (id string, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *AlbumInviteLinkMutation) CreatedByIDs() (ids []string) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *AlbumInviteLinkMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetRevokedByID sets the "revoked_by" edge to the User entity by id.
func (m *AlbumInviteLinkMutation) SetRevokedByID(id string) {
	m.revoked_by = &id
}

// ClearRevokedBy clears the "revoked_by" edge to the User entity.
func (m *AlbumInviteLinkMutation) ClearRevokedBy() {
	m.clearedrevoked_by = true
}

// RevokedByCleared reports if the "revoked_by" edge to the User entity was cleared.
func (m *AlbumInviteLinkMutation) RevokedByCleared() bool {
	return m.clearedrevoked_by
}

// RevokedByID returns the "revoked_by" edge ID in the mutation.
func (m *AlbumInviteLinkMutation) RevokedByID() (id string, exists bool) {
	if m.revoked_by != nil {
		return *m.revoked_by, true
	}
	return
}

// RevokedByIDs returns the "revoked_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevokedByID instead. It exists only for internal usage by the builders.
func (m *AlbumInviteLinkMutation) RevokedByIDs() (ids []string) {
	if id := m.revoked_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevokedBy resets all changes to the "revoked_by" edge.
func (m *AlbumInviteLinkMutation) ResetRevokedBy() {
	m.revoked_by = nil
	m.clearedrevoked_by = false
}

// Where appends a list predicates to the AlbumInviteLinkMutation builder.
func (m *AlbumInviteLinkMutation) Where(ps ...predicate.AlbumInviteLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumInviteLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumInviteLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlbumInviteLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumInviteLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumInviteLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlbumInviteLink).
func (m *AlbumInviteLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumInviteLinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, albuminvitelink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, albuminvitelink.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, albuminvitelink.FieldToken)
	}
	if m.role != nil {
		fields = append(fields, albuminvitelink.FieldRole)
	}
	if m.max_uses != nil {
		fields = append(fields, albuminvitelink.FieldMaxUses)
	}
	if m.uses != nil {
		fields = append(fields, albuminvitelink.FieldUses)
	}
	if m.expires_at != nil {
		fields = append(fields, albuminvitelink.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, albuminvitelink.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumInviteLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case albuminvitelink.FieldCreatedAt:
		return m.CreatedAt()
	case albuminvitelink.FieldUpdatedAt:
		return m.UpdatedAt()
	case albuminvitelink.FieldToken:
		return m.Token()
	case albuminvitelink.FieldRole:
		return m.Role()
	case albuminvitelink.FieldMaxUses:
		return m.MaxUses()
	case albuminvitelink.FieldUses:
		return m.Uses()
	case albuminvitelink.FieldExpiresAt:
		return m.ExpiresAt()
	case albuminvitelink.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumInviteLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case albuminvitelink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case albuminvitelink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case albuminvitelink.FieldToken:
		return m.OldToken(ctx)
	case albuminvitelink.FieldRole:
		return m.OldRole(ctx)
	case albuminvitelink.FieldMaxUses:
		return m.OldMaxUses(ctx)
	case albuminvitelink.FieldUses:
		return m.OldUses(ctx)
	case albuminvitelink.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case albuminvitelink.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlbumInviteLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumInviteLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case albuminvitelink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case albuminvitelink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case albuminvitelink.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case albuminvitelink.FieldRole:
		v, ok := value.(albuminvitelink.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case albuminvitelink.FieldMaxUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUses(v)
		return nil
	case albuminvitelink.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUses(v)
		return nil
	case albuminvitelink.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case albuminvitelink.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumInviteLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumInviteLinkMutation) AddedFields() []string {
	var fields []string
	if m.addmax_uses != nil {
		fields = append(fields, albuminvitelink.FieldMaxUses)
	}
	if m.adduses != nil {
		fields = append(fields, albuminvitelink.FieldUses)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumInviteLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case albuminvitelink.FieldMaxUses:
		return m.AddedMaxUses()
	case albuminvitelink.FieldUses:
		return m.AddedUses()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumInviteLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case albuminvitelink.FieldMaxUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxUses(v)
		return nil
	case albuminvitelink.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUses(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumInviteLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumInviteLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(albuminvitelink.FieldMaxUses) {
		fields = append(fields, albuminvitelink.FieldMaxUses)
	}
	if m.FieldCleared(albuminvitelink.FieldExpiresAt) {
		fields = append(fields, albuminvitelink.FieldExpiresAt)
	}
	if m.FieldCleared(albuminvitelink.FieldRevokedAt) {
		fields = append(fields, albuminvitelink.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumInviteLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumInviteLinkMutation) ClearField(name string) error {
	switch name {
	case albuminvitelink.FieldMaxUses:
		m.ClearMaxUses()
		return nil
	case albuminvitelink.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case albuminvitelink.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown AlbumInviteLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumInviteLinkMutation) ResetField(name string) error {
	switch name {
	case albuminvitelink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case albuminvitelink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case albuminvitelink.FieldToken:
		m.ResetToken()
		return nil
	case albuminvitelink.FieldRole:
		m.ResetRole()
		return nil
	case albuminvitelink.FieldMaxUses:
		m.ResetMaxUses()
		return nil
	case albuminvitelink.FieldUses:
		m.ResetUses()
		return nil
	case albuminvitelink.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case albuminvitelink.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown AlbumInviteLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumInviteLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.album != nil {
		edges = append(edges, albuminvitelink.EdgeAlbum)
	}
	if m.created_by != nil {
		edges = append(edges, albuminvitelink.EdgeCreatedBy)
	}
	if m.revoked_by != nil {
		edges = append(edges, albuminvitelink.EdgeRevokedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumInviteLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case albuminvitelink.EdgeAlbum:
		if id := m.album; id != nil {
			return []ent.Value{*id}
		}
	case albuminvitelink.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case albuminvitelink.EdgeRevokedBy:
		if id := m.revoked_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumInviteLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumInviteLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumInviteLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedalbum {
		edges = append(edges, albuminvitelink.EdgeAlbum)
	}
	if m.clearedcreated_by {
		edges = append(edges, albuminvitelink.EdgeCreatedBy)
	}
	if m.clearedrevoked_by {
		edges = append(edges, albuminvitelink.EdgeRevokedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumInviteLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case albuminvitelink.EdgeAlbum:
		return m.clearedalbum
	case albuminvitelink.EdgeCreatedBy:
		return m.clearedcreated_by
	case albuminvitelink.EdgeRevokedBy:
		return m.clearedrevoked_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumInviteLinkMutation) ClearEdge(name string) error {
	switch name {
	case albuminvitelink.EdgeAlbum:
		m.ClearAlbum()
		return nil
	case albuminvitelink.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case albuminvitelink.EdgeRevokedBy:
		m.ClearRevokedBy()
		return nil
	}
	return fmt.Errorf("unknown AlbumInviteLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumInviteLinkMutation) ResetEdge(name string) error {
	switch name {
	case albuminvitelink.EdgeAlbum:
		m.ResetAlbum()
		return nil
	case albuminvitelink.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case albuminvitelink.EdgeRevokedBy:
		m.ResetRevokedBy()
		return nil
	}
	return fmt.Errorf("unknown AlbumInviteLink edge %s", name)
}

// AlbumPasswordMutation represents an operation that mutates the AlbumPassword nodes in the graph.
type AlbumPasswordMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	role          *albumpassword.Role
	password_hash *string
	revoked_at    *time.Time
	clearedFields map[string]struct{}
	album         *string
	clearedalbum  bool
	done          bool
	oldValue      func(context.Context) (*AlbumPassword, error)
	predicates    []predicate.AlbumPassword
}

var _ ent.Mutation = (*AlbumPasswordMutation)(nil)

// albumpasswordOption allows management of the mutation configuration using functional options.
type albumpasswordOption func(*AlbumPasswordMutation)

// newAlbumPasswordMutation creates new mutation for the AlbumPassword entity.
func newAlbumPasswordMutation(c config, op Op, opts ...albumpasswordOption) *AlbumPasswordMutation {
	m := &AlbumPasswordMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbumPassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumPasswordID sets the ID field of the mutation.
func withAlbumPasswordID(id string) albumpasswordOption {
	return func(m *AlbumPasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *AlbumPassword
		)
		m.oldValue = func(ctx context.Context) (*AlbumPassword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlbumPassword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbumPassword sets the old AlbumPassword of the mutation.
func withAlbumPassword(node *AlbumPassword) albumpasswordOption {
	return func(m *AlbumPasswordMutation) {
		m.oldValue = func(context.Context) (*AlbumPassword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumPasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumPasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlbumPassword entities.
func (m *AlbumPasswordMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumPasswordMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumPasswordMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlbumPassword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumPasswordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumPasswordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlbumPassword entity.
// If the AlbumPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPasswordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumPasswordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumPasswordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumPasswordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlbumPassword entity.
// If the AlbumPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPasswordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumPasswordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRole sets the "role" field.
func (m *AlbumPasswordMutation) SetRole(a albumpassword.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AlbumPasswordMutation) Role() (r albumpassword.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AlbumPassword entity.
// If the AlbumPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPasswordMutation) OldRole(ctx context.Context) (v albumpassword.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AlbumPasswordMutation) ResetRole() {
	m.role = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AlbumPasswordMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AlbumPasswordMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the AlbumPassword entity.
// If the AlbumPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPasswordMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AlbumPasswordMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *AlbumPasswordMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *AlbumPasswordMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the AlbumPassword entity.
// If the AlbumPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPasswordMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *AlbumPasswordMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[albumpassword.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *AlbumPasswordMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[albumpassword.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *AlbumPasswordMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, albumpassword.FieldRevokedAt)
}

// SetAlbumID sets the "album" edge to the Album entity by id.
func (m *AlbumPasswordMutation) SetAlbumID(id string) {
	m.album = &id
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *AlbumPasswordMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *AlbumPasswordMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// AlbumID returns the "album" edge ID in the mutation.
func (m *AlbumPasswordMutation) AlbumID() (id string, exists bool) {
	if m.album != nil {
		return *m.album, true
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlbumID instead. It exists only for internal usage by the builders.
func (m *AlbumPasswordMutation) AlbumIDs() (ids []string) {
	if id := m.album; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *AlbumPasswordMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
}

// Where appends a list predicates to the AlbumPasswordMutation builder.
func (m *AlbumPasswordMutation) Where(ps ...predicate.AlbumPassword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumPasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumPasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlbumPassword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumPasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumPasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlbumPassword).
func (m *AlbumPasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumPasswordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, albumpassword.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, albumpassword.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, albumpassword.FieldRole)
	}
	if m.password_hash != nil {
		fields = append(fields, albumpassword.FieldPasswordHash)
	}
	if m.revoked_at != nil {
		fields = append(fields, albumpassword.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumPasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case albumpassword.FieldCreatedAt:
		return m.CreatedAt()
	case albumpassword.FieldUpdatedAt:
		return m.UpdatedAt()
	case albumpassword.FieldRole:
		return m.Role()
	case albumpassword.FieldPasswordHash:
		return m.PasswordHash()
	case albumpassword.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumPasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case albumpassword.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case albumpassword.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case albumpassword.FieldRole:
		return m.OldRole(ctx)
	case albumpassword.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case albumpassword.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlbumPassword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumPasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case albumpassword.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case albumpassword.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case albumpassword.FieldRole:
		v, ok := value.(albumpassword.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case albumpassword.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case albumpassword.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumPassword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumPasswordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumPasswordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumPasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlbumPassword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumPasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(albumpassword.FieldRevokedAt) {
		fields = append(fields, albumpassword.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumPasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumPasswordMutation) ClearField(name string) error {
	switch name {
	case albumpassword.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown AlbumPassword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumPasswordMutation) ResetField(name string) error {
	switch name {
	case albumpassword.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case albumpassword.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case albumpassword.FieldRole:
		m.ResetRole()
		return nil
	case albumpassword.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case albumpassword.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown AlbumPassword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumPasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.album != nil {
		edges = append(edges, albumpassword.EdgeAlbum)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumPasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case albumpassword.EdgeAlbum:
		if id := m.album; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumPasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumPasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumPasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedalbum {
		edges = append(edges, albumpassword.EdgeAlbum)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumPasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case albumpassword.EdgeAlbum:
		return m.clearedalbum
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumPasswordMutation) ClearEdge(name string) error {
	switch name {
	case albumpassword.EdgeAlbum:
		m.ClearAlbum()
		return nil
	}
	return fmt.Errorf("unknown AlbumPassword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumPasswordMutation) ResetEdge(name string) error {
	switch name {
	case albumpassword.EdgeAlbum:
		m.ResetAlbum()
		return nil
	}
	return fmt.Errorf("unknown AlbumPassword edge %s", name)
}

// AlbumUserMutation represents an operation that mutates the AlbumUser nodes in the graph.
type AlbumUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	role          *albumuser.Role
	clearedFields map[string]struct{}
	album         *string
	clearedalbum  bool
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AlbumUser, error)
	predicates    []predicate.AlbumUser
}

var _ ent.Mutation = (*AlbumUserMutation)(nil)

// albumuserOption allows management of the mutation configuration using functional options.
type albumuserOption func(*AlbumUserMutation)

// newAlbumUserMutation creates new mutation for the AlbumUser entity.
func newAlbumUserMutation(c config, op Op, opts ...albumuserOption) *AlbumUserMutation {
	m := &AlbumUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbumUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumUserID sets the ID field of the mutation.
func withAlbumUserID(id int) albumuserOption {
	return func(m *AlbumUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AlbumUser
		)
		m.oldValue = func(ctx context.Context) (*AlbumUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlbumUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbumUser sets the old AlbumUser of the mutation.
func withAlbumUser(node *AlbumUser) albumuserOption {
	return func(m *AlbumUserMutation) {
		m.oldValue = func(context.Context) (*AlbumUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlbumUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlbumUser entity.
// If the AlbumUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlbumUser entity.
// If the AlbumUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRole sets the "role" field.
func (m *AlbumUserMutation) SetRole(a albumuser.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AlbumUserMutation) Role() (r albumuser.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AlbumUser entity.
// If the AlbumUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumUserMutation) OldRole(ctx context.Context) (v albumuser.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AlbumUserMutation) ResetRole() {
	m.role = nil
}

// SetAlbumID sets the "album" edge to the Album entity by id.
func (m *AlbumUserMutation) SetAlbumID(id string) {
	m.album = &id
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *AlbumUserMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *AlbumUserMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// AlbumID returns the "album" edge ID in the mutation.
func (m *AlbumUserMutation) AlbumID() (id string, exists bool) {
	if m.album != nil {
		return *m.album, true
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlbumID instead. It exists only for internal usage by the builders.
func (m *AlbumUserMutation) AlbumIDs() (ids []string) {
	if id := m.album; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *AlbumUserMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AlbumUserMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AlbumUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AlbumUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AlbumUserMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AlbumUserMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AlbumUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AlbumUserMutation builder.
func (m *AlbumUserMutation) Where(ps ...predicate.AlbumUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlbumUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlbumUser).
func (m *AlbumUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, albumuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, albumuser.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, albumuser.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case albumuser.FieldCreatedAt:
		return m.CreatedAt()
	case albumuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case albumuser.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case albumuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case albumuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case albumuser.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown AlbumUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case albumuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case albumuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case albumuser.FieldRole:
		v, ok := value.(albumuser.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlbumUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AlbumUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumUserMutation) ResetField(name string) error {
	switch name {
	case albumuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case albumuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case albumuser.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AlbumUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.album != nil {
		edges = append(edges, albumuser.EdgeAlbum)
	}
	if m.user != nil {
		edges = append(edges, albumuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case albumuser.EdgeAlbum:
		if id := m.album; id != nil {
			return []ent.Value{*id}
		}
	case albumuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalbum {
		edges = append(edges, albumuser.EdgeAlbum)
	}
	if m.cleareduser {
		edges = append(edges, albumuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumUserMutation) EdgeCleared(name string) bool {
	switch name {
	case albumuser.EdgeAlbum:
		return m.clearedalbum
	case albumuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumUserMutation) ClearEdge(name string) error {
	switch name {
	case albumuser.EdgeAlbum:
		m.ClearAlbum()
		return nil
	case albumuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AlbumUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumUserMutation) ResetEdge(name string) error {
	switch name {
	case albumuser.EdgeAlbum:
		m.ResetAlbum()
		return nil
	case albumuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AlbumUser edge %s", name)
}

// CreditUsageMutation represents an operation that mutates the CreditUsage nodes in the graph.
type CreditUsageMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	amount                 *int64
	addamount              *int64
	reason                 *string
	clearedFields          map[string]struct{}
	user                   *string
	cleareduser            bool
	generated_photo        *string
	clearedgenerated_photo bool
	done                   bool
	oldValue               func(context.Context) (*CreditUsage, error)
	predicates             []predicate.CreditUsage
}

var _ ent.Mutation = (*CreditUsageMutation)(nil)

// creditusageOption allows management of the mutation configuration using functional options.
type creditusageOption func(*CreditUsageMutation)

// newCreditUsageMutation creates new mutation for the CreditUsage entity.
func newCreditUsageMutation(c config, op Op, opts ...creditusageOption) *CreditUsageMutation {
	m := &CreditUsageMutation{
		config:        c,
		op:            op,
		typ:           TypeCreditUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditUsageID sets the ID field of the mutation.
func withCreditUsageID(id string) creditusageOption {
	return func(m *CreditUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *CreditUsage
		)
		m.oldValue = func(ctx context.Context) (*CreditUsage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CreditUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreditUsage sets the old CreditUsage of the mutation.
func withCreditUsage(node *CreditUsage) creditusageOption {
	return func(m *CreditUsageMutation) {
		m.oldValue = func(context.Context) (*CreditUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CreditUsage entities.
func (m *CreditUsageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditUsageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditUsageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CreditUsage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditUsageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditUsageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CreditUsage entity.
// If the CreditUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditUsageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditUsageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreditUsageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreditUsageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CreditUsage entity.
// If the CreditUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditUsageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreditUsageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAmount sets the "amount" field.
func (m *CreditUsageMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CreditUsageMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CreditUsage entity.
// If the CreditUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditUsageMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *CreditUsageMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CreditUsageMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CreditUsageMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetReason sets the "reason" field.
func (m *CreditUsageMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *CreditUsageMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the CreditUsage entity.
// If the CreditUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditUsageMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *CreditUsageMutation) ResetReason() {
	m.reason = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CreditUsageMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CreditUsageMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CreditUsageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CreditUsageMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CreditUsageMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CreditUsageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetGeneratedPhotoID sets the "generated_photo" edge to the GeneratedPhoto entity by id.
func (m *CreditUsageMutation) SetGeneratedPhotoID(id string) {
	m.generated_photo = &id
}

// ClearGeneratedPhoto clears the "generated_photo" edge to the GeneratedPhoto entity.
func (m *CreditUsageMutation) ClearGeneratedPhoto() {
	m.clearedgenerated_photo = true
}

// GeneratedPhotoCleared reports if the "generated_photo" edge to the GeneratedPhoto entity was cleared.
func (m *CreditUsageMutation) GeneratedPhotoCleared() bool {
	return m.clearedgenerated_photo
}

// GeneratedPhotoID returns the "generated_photo" edge ID in the mutation.
func (m *CreditUsageMutation) GeneratedPhotoID() (id string, exists bool) {
	if m.generated_photo != nil {
		return *m.generated_photo, true
	}
	return
}

// GeneratedPhotoIDs returns the "generated_photo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GeneratedPhotoID instead. It exists only for internal usage by the builders.
func (m *CreditUsageMutation) GeneratedPhotoIDs() (ids []string) {
	if id := m.generated_photo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGeneratedPhoto resets all changes to the "generated_photo" edge.
func (m *CreditUsageMutation) ResetGeneratedPhoto() {
	m.generated_photo = nil
	m.clearedgenerated_photo = false
}

// Where appends a list predicates to the CreditUsageMutation builder.
func (m *CreditUsageMutation) Where(ps ...predicate.CreditUsage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditUsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditUsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CreditUsage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditUsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditUsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CreditUsage).
func (m *CreditUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditUsageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, creditusage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, creditusage.FieldUpdatedAt)
	}
	if m.amount != nil {
		fields = append(fields, creditusage.FieldAmount)
	}
	if m.reason != nil {
		fields = append(fields, creditusage.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditUsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case creditusage.FieldCreatedAt:
		return m.CreatedAt()
	case creditusage.FieldUpdatedAt:
		return m.UpdatedAt()
	case creditusage.FieldAmount:
		return m.Amount()
	case creditusage.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case creditusage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case creditusage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case creditusage.FieldAmount:
		return m.OldAmount(ctx)
	case creditusage.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown CreditUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case creditusage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case creditusage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case creditusage.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case creditusage.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown CreditUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditUsageMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, creditusage.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditUsageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case creditusage.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditUsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case creditusage.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CreditUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditUsageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditUsageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CreditUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditUsageMutation) ResetField(name string) error {
	switch name {
	case creditusage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case creditusage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case creditusage.FieldAmount:
		m.ResetAmount()
		return nil
	case creditusage.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown CreditUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, creditusage.EdgeUser)
	}
	if m.generated_photo != nil {
		edges = append(edges, creditusage.EdgeGeneratedPhoto)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditUsageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case creditusage.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case creditusage.EdgeGeneratedPhoto:
		if id := m.generated_photo; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditUsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, creditusage.EdgeUser)
	}
	if m.clearedgenerated_photo {
		edges = append(edges, creditusage.EdgeGeneratedPhoto)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditUsageMutation) EdgeCleared(name string) bool {
	switch name {
	case creditusage.EdgeUser:
		return m.cleareduser
	case creditusage.EdgeGeneratedPhoto:
		return m.clearedgenerated_photo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditUsageMutation) ClearEdge(name string) error {
	switch name {
	case creditusage.EdgeUser:
		m.ClearUser()
		return nil
	case creditusage.EdgeGeneratedPhoto:
		m.ClearGeneratedPhoto()
		return nil
	}
	return fmt.Errorf("unknown CreditUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditUsageMutation) ResetEdge(name string) error {
	switch name {
	case creditusage.EdgeUser:
		m.ResetUser()
		return nil
	case creditusage.EdgeGeneratedPhoto:
		m.ResetGeneratedPhoto()
		return nil
	}
	return fmt.Errorf("unknown CreditUsage edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	provider            *string
	provider_key        *string
	original_name       *string
	mime_type           *string
	size_bytes          *int64
	addsize_bytes       *int64
	clearedFields       map[string]struct{}
	original_of         map[string]struct{}
	removedoriginal_of  map[string]struct{}
	clearedoriginal_of  bool
	generated_of        map[string]struct{}
	removedgenerated_of map[string]struct{}
	clearedgenerated_of bool
	done                bool
	oldValue            func(context.Context) (*File, error)
	predicates          []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id string) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProvider sets the "provider" field.
func (m *FileMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *FileMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *FileMutation) ResetProvider() {
	m.provider = nil
}

// SetProviderKey sets the "provider_key" field.
func (m *FileMutation) SetProviderKey(s string) {
	m.provider_key = &s
}

// ProviderKey returns the value of the "provider_key" field in the mutation.
func (m *FileMutation) ProviderKey() (r string, exists bool) {
	v := m.provider_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderKey returns the old "provider_key" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProviderKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderKey: %w", err)
	}
	return oldValue.ProviderKey, nil
}

// ClearProviderKey clears the value of the "provider_key" field.
func (m *FileMutation) ClearProviderKey() {
	m.provider_key = nil
	m.clearedFields[file.FieldProviderKey] = struct{}{}
}

// ProviderKeyCleared returns if the "provider_key" field was cleared in this mutation.
func (m *FileMutation) ProviderKeyCleared() bool {
	_, ok := m.clearedFields[file.FieldProviderKey]
	return ok
}

// ResetProviderKey resets all changes to the "provider_key" field.
func (m *FileMutation) ResetProviderKey() {
	m.provider_key = nil
	delete(m.clearedFields, file.FieldProviderKey)
}

// SetOriginalName sets the "original_name" field.
func (m *FileMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *FileMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ClearOriginalName clears the value of the "original_name" field.
func (m *FileMutation) ClearOriginalName() {
	m.original_name = nil
	m.clearedFields[file.FieldOriginalName] = struct{}{}
}

// OriginalNameCleared returns if the "original_name" field was cleared in this mutation.
func (m *FileMutation) OriginalNameCleared() bool {
	_, ok := m.clearedFields[file.FieldOriginalName]
	return ok
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *FileMutation) ResetOriginalName() {
	m.original_name = nil
	delete(m.clearedFields, file.FieldOriginalName)
}

// SetMimeType sets the "mime_type" field.
func (m *FileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *FileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *FileMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[file.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *FileMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[file.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *FileMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, file.FieldMimeType)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *FileMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *FileMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *FileMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *FileMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *FileMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// AddOriginalOfIDs adds the "original_of" edge to the OriginalPhoto entity by ids.
func (m *FileMutation) AddOriginalOfIDs(ids ...string) {
	if m.original_of == nil {
		m.original_of = make(map[string]struct{})
	}
	for i := range ids {
		m.original_of[ids[i]] = struct{}{}
	}
}

// ClearOriginalOf clears the "original_of" edge to the OriginalPhoto entity.
func (m *FileMutation) ClearOriginalOf() {
	m.clearedoriginal_of = true
}

// OriginalOfCleared reports if the "original_of" edge to the OriginalPhoto entity was cleared.
func (m *FileMutation) OriginalOfCleared() bool {
	return m.clearedoriginal_of
}

// RemoveOriginalOfIDs removes the "original_of" edge to the OriginalPhoto entity by IDs.
func (m *FileMutation) RemoveOriginalOfIDs(ids ...string) {
	if m.removedoriginal_of == nil {
		m.removedoriginal_of = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.original_of, ids[i])
		m.removedoriginal_of[ids[i]] = struct{}{}
	}
}

// RemovedOriginalOf returns the removed IDs of the "original_of" edge to the OriginalPhoto entity.
func (m *FileMutation) RemovedOriginalOfIDs() (ids []string) {
	for id := range m.removedoriginal_of {
		ids = append(ids, id)
	}
	return
}

// OriginalOfIDs returns the "original_of" edge IDs in the mutation.
func (m *FileMutation) OriginalOfIDs() (ids []string) {
	for id := range m.original_of {
		ids = append(ids, id)
	}
	return
}

// ResetOriginalOf resets all changes to the "original_of" edge.
func (m *FileMutation) ResetOriginalOf() {
	m.original_of = nil
	m.clearedoriginal_of = false
	m.removedoriginal_of = nil
}

// AddGeneratedOfIDs adds the "generated_of" edge to the GeneratedPhoto entity by ids.
func (m *FileMutation) AddGeneratedOfIDs(ids ...string) {
	if m.generated_of == nil {
		m.generated_of = make(map[string]struct{})
	}
	for i := range ids {
		m.generated_of[ids[i]] = struct{}{}
	}
}

// ClearGeneratedOf clears the "generated_of" edge to the GeneratedPhoto entity.
func (m *FileMutation) ClearGeneratedOf() {
	m.clearedgenerated_of = true
}

// GeneratedOfCleared reports if the "generated_of" edge to the GeneratedPhoto entity was cleared.
func (m *FileMutation) GeneratedOfCleared() bool {
	return m.clearedgenerated_of
}

// RemoveGeneratedOfIDs removes the "generated_of" edge to the GeneratedPhoto entity by IDs.
func (m *FileMutation) RemoveGeneratedOfIDs(ids ...string) {
	if m.removedgenerated_of == nil {
		m.removedgenerated_of = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.generated_of, ids[i])
		m.removedgenerated_of[ids[i]] = struct{}{}
	}
}

// RemovedGeneratedOf returns the removed IDs of the "generated_of" edge to the GeneratedPhoto entity.
func (m *FileMutation) RemovedGeneratedOfIDs() (ids []string) {
	for id := range m.removedgenerated_of {
		ids = append(ids, id)
	}
	return
}

// GeneratedOfIDs returns the "generated_of" edge IDs in the mutation.
func (m *FileMutation) GeneratedOfIDs() (ids []string) {
	for id := range m.generated_of {
		ids = append(ids, id)
	}
	return
}

// ResetGeneratedOf resets all changes to the "generated_of" edge.
func (m *FileMutation) ResetGeneratedOf() {
	m.generated_of = nil
	m.clearedgenerated_of = false
	m.removedgenerated_of = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.provider != nil {
		fields = append(fields, file.FieldProvider)
	}
	if m.provider_key != nil {
		fields = append(fields, file.FieldProviderKey)
	}
	if m.original_name != nil {
		fields = append(fields, file.FieldOriginalName)
	}
	if m.mime_type != nil {
		fields = append(fields, file.FieldMimeType)
	}
	if m.size_bytes != nil {
		fields = append(fields, file.FieldSizeBytes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldProvider:
		return m.Provider()
	case file.FieldProviderKey:
		return m.ProviderKey()
	case file.FieldOriginalName:
		return m.OriginalName()
	case file.FieldMimeType:
		return m.MimeType()
	case file.FieldSizeBytes:
		return m.SizeBytes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldProvider:
		return m.OldProvider(ctx)
	case file.FieldProviderKey:
		return m.OldProviderKey(ctx)
	case file.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case file.FieldMimeType:
		return m.OldMimeType(ctx)
	case file.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case file.FieldProviderKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderKey(v)
		return nil
	case file.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case file.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case file.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, file.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldProviderKey) {
		fields = append(fields, file.FieldProviderKey)
	}
	if m.FieldCleared(file.FieldOriginalName) {
		fields = append(fields, file.FieldOriginalName)
	}
	if m.FieldCleared(file.FieldMimeType) {
		fields = append(fields, file.FieldMimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldProviderKey:
		m.ClearProviderKey()
		return nil
	case file.FieldOriginalName:
		m.ClearOriginalName()
		return nil
	case file.FieldMimeType:
		m.ClearMimeType()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldProvider:
		m.ResetProvider()
		return nil
	case file.FieldProviderKey:
		m.ResetProviderKey()
		return nil
	case file.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case file.FieldMimeType:
		m.ResetMimeType()
		return nil
	case file.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.original_of != nil {
		edges = append(edges, file.EdgeOriginalOf)
	}
	if m.generated_of != nil {
		edges = append(edges, file.EdgeGeneratedOf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOriginalOf:
		ids := make([]ent.Value, 0, len(m.original_of))
		for id := range m.original_of {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeGeneratedOf:
		ids := make([]ent.Value, 0, len(m.generated_of))
		for id := range m.generated_of {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoriginal_of != nil {
		edges = append(edges, file.EdgeOriginalOf)
	}
	if m.removedgenerated_of != nil {
		edges = append(edges, file.EdgeGeneratedOf)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOriginalOf:
		ids := make([]ent.Value, 0, len(m.removedoriginal_of))
		for id := range m.removedoriginal_of {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeGeneratedOf:
		ids := make([]ent.Value, 0, len(m.removedgenerated_of))
		for id := range m.removedgenerated_of {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoriginal_of {
		edges = append(edges, file.EdgeOriginalOf)
	}
	if m.clearedgenerated_of {
		edges = append(edges, file.EdgeGeneratedOf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOriginalOf:
		return m.clearedoriginal_of
	case file.EdgeGeneratedOf:
		return m.clearedgenerated_of
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOriginalOf:
		m.ResetOriginalOf()
		return nil
	case file.EdgeGeneratedOf:
		m.ResetGeneratedOf()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// GeneratedPhotoMutation represents an operation that mutates the GeneratedPhoto nodes in the graph.
type GeneratedPhotoMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	status                *generatedphoto.Status
	started_at            *time.Time
	finished_at           *time.Time
	error_message         *string
	clearedFields         map[string]struct{}
	original_photo        *string
	clearedoriginal_photo bool
	theme                 *string
	clearedtheme          bool
	file                  *string
	clearedfile           bool
	credit_usages         map[string]struct{}
	removedcredit_usages  map[string]struct{}
	clearedcredit_usages  bool
	done                  bool
	oldValue              func(context.Context) (*GeneratedPhoto, error)
	predicates            []predicate.GeneratedPhoto
}

var _ ent.Mutation = (*GeneratedPhotoMutation)(nil)

// generatedphotoOption allows management of the mutation configuration using functional options.
type generatedphotoOption func(*GeneratedPhotoMutation)

// newGeneratedPhotoMutation creates new mutation for the GeneratedPhoto entity.
func newGeneratedPhotoMutation(c config, op Op, opts ...generatedphotoOption) *GeneratedPhotoMutation {
	m := &GeneratedPhotoMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneratedPhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeneratedPhotoID sets the ID field of the mutation.
func withGeneratedPhotoID(id string) generatedphotoOption {
	return func(m *GeneratedPhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *GeneratedPhoto
		)
		m.oldValue = func(ctx context.Context) (*GeneratedPhoto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GeneratedPhoto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneratedPhoto sets the old GeneratedPhoto of the mutation.
func withGeneratedPhoto(node *GeneratedPhoto) generatedphotoOption {
	return func(m *GeneratedPhotoMutation) {
		m.oldValue = func(context.Context) (*GeneratedPhoto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeneratedPhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeneratedPhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GeneratedPhoto entities.
func (m *GeneratedPhotoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeneratedPhotoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeneratedPhotoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GeneratedPhoto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GeneratedPhotoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GeneratedPhotoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GeneratedPhotoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GeneratedPhotoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GeneratedPhotoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GeneratedPhotoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GeneratedPhotoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GeneratedPhotoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GeneratedPhotoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[generatedphoto.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GeneratedPhotoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[generatedphoto.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GeneratedPhotoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, generatedphoto.FieldDeletedAt)
}

// SetStatus sets the "status" field.
func (m *GeneratedPhotoMutation) SetStatus(ge generatedphoto.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GeneratedPhotoMutation) Status() (r generatedphoto.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldStatus(ctx context.Context) (v generatedphoto.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GeneratedPhotoMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *GeneratedPhotoMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *GeneratedPhotoMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *GeneratedPhotoMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *GeneratedPhotoMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *GeneratedPhotoMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *GeneratedPhotoMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[generatedphoto.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *GeneratedPhotoMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[generatedphoto.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *GeneratedPhotoMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, generatedphoto.FieldFinishedAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *GeneratedPhotoMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *GeneratedPhotoMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the GeneratedPhoto entity.
// If the GeneratedPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedPhotoMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *GeneratedPhotoMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[generatedphoto.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *GeneratedPhotoMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[generatedphoto.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *GeneratedPhotoMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, generatedphoto.FieldErrorMessage)
}

// SetOriginalPhotoID sets the "original_photo" edge to the OriginalPhoto entity by id.
func (m *GeneratedPhotoMutation) SetOriginalPhotoID(id string) {
	m.original_photo = &id
}

// ClearOriginalPhoto clears the "original_photo" edge to the OriginalPhoto entity.
func (m *GeneratedPhotoMutation) ClearOriginalPhoto() {
	m.clearedoriginal_photo = true
}

// OriginalPhotoCleared reports if the "original_photo" edge to the OriginalPhoto entity was cleared.
func (m *GeneratedPhotoMutation) OriginalPhotoCleared() bool {
	return m.clearedoriginal_photo
}

// OriginalPhotoID returns the "original_photo" edge ID in the mutation.
func (m *GeneratedPhotoMutation) OriginalPhotoID() (id string, exists bool) {
	if m.original_photo != nil {
		return *m.original_photo, true
	}
	return
}

// OriginalPhotoIDs returns the "original_photo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OriginalPhotoID instead. It exists only for internal usage by the builders.
func (m *GeneratedPhotoMutation) OriginalPhotoIDs() (ids []string) {
	if id := m.original_photo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOriginalPhoto resets all changes to the "original_photo" edge.
func (m *GeneratedPhotoMutation) ResetOriginalPhoto() {
	m.original_photo = nil
	m.clearedoriginal_photo = false
}

// SetThemeID sets the "theme" edge to the Theme entity by id.
func (m *GeneratedPhotoMutation) SetThemeID(id string) {
	m.theme = &id
}

// ClearTheme clears the "theme" edge to the Theme entity.
func (m *GeneratedPhotoMutation) ClearTheme() {
	m.clearedtheme = true
}

// ThemeCleared reports if the "theme" edge to the Theme entity was cleared.
func (m *GeneratedPhotoMutation) ThemeCleared() bool {
	return m.clearedtheme
}

// ThemeID returns the "theme" edge ID in the mutation.
func (m *GeneratedPhotoMutation) ThemeID() (id string, exists bool) {
	if m.theme != nil {
		return *m.theme, true
	}
	return
}

// ThemeIDs returns the "theme" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThemeID instead. It exists only for internal usage by the builders.
func (m *GeneratedPhotoMutation) ThemeIDs() (ids []string) {
	if id := m.theme; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTheme resets all changes to the "theme" edge.
func (m *GeneratedPhotoMutation) ResetTheme() {
	m.theme = nil
	m.clearedtheme = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *GeneratedPhotoMutation) SetFileID(id string) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *GeneratedPhotoMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *GeneratedPhotoMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *GeneratedPhotoMutation) FileID() (id string, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *GeneratedPhotoMutation) FileIDs() (ids []string) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *GeneratedPhotoMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// AddCreditUsageIDs adds the "credit_usages" edge to the CreditUsage entity by ids.
func (m *GeneratedPhotoMutation) AddCreditUsageIDs(ids ...string) {
	if m.credit_usages == nil {
		m.credit_usages = make(map[string]struct{})
	}
	for i := range ids {
		m.credit_usages[ids[i]] = struct{}{}
	}
}

// ClearCreditUsages clears the "credit_usages" edge to the CreditUsage entity.
func (m *GeneratedPhotoMutation) ClearCreditUsages() {
	m.clearedcredit_usages = true
}

// CreditUsagesCleared reports if the "credit_usages" edge to the CreditUsage entity was cleared.
func (m *GeneratedPhotoMutation) CreditUsagesCleared() bool {
	return m.clearedcredit_usages
}

// RemoveCreditUsageIDs removes the "credit_usages" edge to the CreditUsage entity by IDs.
func (m *GeneratedPhotoMutation) RemoveCreditUsageIDs(ids ...string) {
	if m.removedcredit_usages == nil {
		m.removedcredit_usages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credit_usages, ids[i])
		m.removedcredit_usages[ids[i]] = struct{}{}
	}
}

// RemovedCreditUsages returns the removed IDs of the "credit_usages" edge to the CreditUsage entity.
func (m *GeneratedPhotoMutation) RemovedCreditUsagesIDs() (ids []string) {
	for id := range m.removedcredit_usages {
		ids = append(ids, id)
	}
	return
}

// CreditUsagesIDs returns the "credit_usages" edge IDs in the mutation.
func (m *GeneratedPhotoMutation) CreditUsagesIDs() (ids []string) {
	for id := range m.credit_usages {
		ids = append(ids, id)
	}
	return
}

// ResetCreditUsages resets all changes to the "credit_usages" edge.
func (m *GeneratedPhotoMutation) ResetCreditUsages() {
	m.credit_usages = nil
	m.clearedcredit_usages = false
	m.removedcredit_usages = nil
}

// Where appends a list predicates to the GeneratedPhotoMutation builder.
func (m *GeneratedPhotoMutation) Where(ps ...predicate.GeneratedPhoto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeneratedPhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeneratedPhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GeneratedPhoto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeneratedPhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeneratedPhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GeneratedPhoto).
func (m *GeneratedPhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeneratedPhotoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, generatedphoto.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generatedphoto.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, generatedphoto.FieldDeletedAt)
	}
	if m.status != nil {
		fields = append(fields, generatedphoto.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, generatedphoto.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, generatedphoto.FieldFinishedAt)
	}
	if m.error_message != nil {
		fields = append(fields, generatedphoto.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeneratedPhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generatedphoto.FieldCreatedAt:
		return m.CreatedAt()
	case generatedphoto.FieldUpdatedAt:
		return m.UpdatedAt()
	case generatedphoto.FieldDeletedAt:
		return m.DeletedAt()
	case generatedphoto.FieldStatus:
		return m.Status()
	case generatedphoto.FieldStartedAt:
		return m.StartedAt()
	case generatedphoto.FieldFinishedAt:
		return m.FinishedAt()
	case generatedphoto.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeneratedPhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generatedphoto.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generatedphoto.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case generatedphoto.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case generatedphoto.FieldStatus:
		return m.OldStatus(ctx)
	case generatedphoto.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case generatedphoto.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case generatedphoto.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown GeneratedPhoto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneratedPhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generatedphoto.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generatedphoto.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case generatedphoto.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case generatedphoto.FieldStatus:
		v, ok := value.(generatedphoto.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generatedphoto.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case generatedphoto.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case generatedphoto.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown GeneratedPhoto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeneratedPhotoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeneratedPhotoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneratedPhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GeneratedPhoto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeneratedPhotoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generatedphoto.FieldDeletedAt) {
		fields = append(fields, generatedphoto.FieldDeletedAt)
	}
	if m.FieldCleared(generatedphoto.FieldFinishedAt) {
		fields = append(fields, generatedphoto.FieldFinishedAt)
	}
	if m.FieldCleared(generatedphoto.FieldErrorMessage) {
		fields = append(fields, generatedphoto.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeneratedPhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeneratedPhotoMutation) ClearField(name string) error {
	switch name {
	case generatedphoto.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case generatedphoto.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case generatedphoto.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown GeneratedPhoto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeneratedPhotoMutation) ResetField(name string) error {
	switch name {
	case generatedphoto.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generatedphoto.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case generatedphoto.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case generatedphoto.FieldStatus:
		m.ResetStatus()
		return nil
	case generatedphoto.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case generatedphoto.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case generatedphoto.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown GeneratedPhoto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeneratedPhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.original_photo != nil {
		edges = append(edges, generatedphoto.EdgeOriginalPhoto)
	}
	if m.theme != nil {
		edges = append(edges, generatedphoto.EdgeTheme)
	}
	if m.file != nil {
		edges = append(edges, generatedphoto.EdgeFile)
	}
	if m.credit_usages != nil {
		edges = append(edges, generatedphoto.EdgeCreditUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeneratedPhotoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generatedphoto.EdgeOriginalPhoto:
		if id := m.original_photo; id != nil {
			return []ent.Value{*id}
		}
	case generatedphoto.EdgeTheme:
		if id := m.theme; id != nil {
			return []ent.Value{*id}
		}
	case generatedphoto.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case generatedphoto.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.credit_usages))
		for id := range m.credit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeneratedPhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcredit_usages != nil {
		edges = append(edges, generatedphoto.EdgeCreditUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeneratedPhotoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generatedphoto.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.removedcredit_usages))
		for id := range m.removedcredit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeneratedPhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedoriginal_photo {
		edges = append(edges, generatedphoto.EdgeOriginalPhoto)
	}
	if m.clearedtheme {
		edges = append(edges, generatedphoto.EdgeTheme)
	}
	if m.clearedfile {
		edges = append(edges, generatedphoto.EdgeFile)
	}
	if m.clearedcredit_usages {
		edges = append(edges, generatedphoto.EdgeCreditUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeneratedPhotoMutation) EdgeCleared(name string) bool {
	switch name {
	case generatedphoto.EdgeOriginalPhoto:
		return m.clearedoriginal_photo
	case generatedphoto.EdgeTheme:
		return m.clearedtheme
	case generatedphoto.EdgeFile:
		return m.clearedfile
	case generatedphoto.EdgeCreditUsages:
		return m.clearedcredit_usages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeneratedPhotoMutation) ClearEdge(name string) error {
	switch name {
	case generatedphoto.EdgeOriginalPhoto:
		m.ClearOriginalPhoto()
		return nil
	case generatedphoto.EdgeTheme:
		m.ClearTheme()
		return nil
	case generatedphoto.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown GeneratedPhoto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeneratedPhotoMutation) ResetEdge(name string) error {
	switch name {
	case generatedphoto.EdgeOriginalPhoto:
		m.ResetOriginalPhoto()
		return nil
	case generatedphoto.EdgeTheme:
		m.ResetTheme()
		return nil
	case generatedphoto.EdgeFile:
		m.ResetFile()
		return nil
	case generatedphoto.EdgeCreditUsages:
		m.ResetCreditUsages()
		return nil
	}
	return fmt.Errorf("unknown GeneratedPhoto edge %s", name)
}

// OriginalPhotoMutation represents an operation that mutates the OriginalPhoto nodes in the graph.
type OriginalPhotoMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	album                *string
	clearedalbum         bool
	file                 *string
	clearedfile          bool
	uploaded_by          *string
	cleareduploaded_by   bool
	generated            map[string]struct{}
	removedgenerated     map[string]struct{}
	clearedgenerated     bool
	credit_usages        map[string]struct{}
	removedcredit_usages map[string]struct{}
	clearedcredit_usages bool
	done                 bool
	oldValue             func(context.Context) (*OriginalPhoto, error)
	predicates           []predicate.OriginalPhoto
}

var _ ent.Mutation = (*OriginalPhotoMutation)(nil)

// originalphotoOption allows management of the mutation configuration using functional options.
type originalphotoOption func(*OriginalPhotoMutation)

// newOriginalPhotoMutation creates new mutation for the OriginalPhoto entity.
func newOriginalPhotoMutation(c config, op Op, opts ...originalphotoOption) *OriginalPhotoMutation {
	m := &OriginalPhotoMutation{
		config:        c,
		op:            op,
		typ:           TypeOriginalPhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOriginalPhotoID sets the ID field of the mutation.
func withOriginalPhotoID(id string) originalphotoOption {
	return func(m *OriginalPhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *OriginalPhoto
		)
		m.oldValue = func(ctx context.Context) (*OriginalPhoto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OriginalPhoto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOriginalPhoto sets the old OriginalPhoto of the mutation.
func withOriginalPhoto(node *OriginalPhoto) originalphotoOption {
	return func(m *OriginalPhotoMutation) {
		m.oldValue = func(context.Context) (*OriginalPhoto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OriginalPhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OriginalPhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OriginalPhoto entities.
func (m *OriginalPhotoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OriginalPhotoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OriginalPhotoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OriginalPhoto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OriginalPhotoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OriginalPhotoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OriginalPhoto entity.
// If the OriginalPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginalPhotoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OriginalPhotoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OriginalPhotoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OriginalPhotoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OriginalPhoto entity.
// If the OriginalPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginalPhotoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OriginalPhotoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OriginalPhotoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OriginalPhotoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OriginalPhoto entity.
// If the OriginalPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OriginalPhotoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OriginalPhotoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[originalphoto.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OriginalPhotoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[originalphoto.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OriginalPhotoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, originalphoto.FieldDeletedAt)
}

// SetAlbumID sets the "album" edge to the Album entity by id.
func (m *OriginalPhotoMutation) SetAlbumID(id string) {
	m.album = &id
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *OriginalPhotoMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *OriginalPhotoMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// AlbumID returns the "album" edge ID in the mutation.
func (m *OriginalPhotoMutation) AlbumID() (id string, exists bool) {
	if m.album != nil {
		return *m.album, true
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlbumID instead. It exists only for internal usage by the builders.
func (m *OriginalPhotoMutation) AlbumIDs() (ids []string) {
	if id := m.album; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *OriginalPhotoMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *OriginalPhotoMutation) SetFileID(id string) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *OriginalPhotoMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *OriginalPhotoMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *OriginalPhotoMutation) FileID() (id string, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *OriginalPhotoMutation) FileIDs() (ids []string) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *OriginalPhotoMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetUploadedByID sets the "uploaded_by" edge to the User entity by id.
func (m *OriginalPhotoMutation) SetUploadedByID(id string) {
	m.uploaded_by = &id
}

// ClearUploadedBy clears the "uploaded_by" edge to the User entity.
func (m *OriginalPhotoMutation) ClearUploadedBy() {
	m.cleareduploaded_by = true
}

// UploadedByCleared reports if the "uploaded_by" edge to the User entity was cleared.
func (m *OriginalPhotoMutation) UploadedByCleared() bool {
	return m.cleareduploaded_by
}

// UploadedByID returns the "uploaded_by" edge ID in the mutation.
func (m *OriginalPhotoMutation) UploadedByID() (id string, exists bool) {
	if m.uploaded_by != nil {
		return *m.uploaded_by, true
	}
	return
}

// UploadedByIDs returns the "uploaded_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploadedByID instead. It exists only for internal usage by the builders.
func (m *OriginalPhotoMutation) UploadedByIDs() (ids []string) {
	if id := m.uploaded_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploadedBy resets all changes to the "uploaded_by" edge.
func (m *OriginalPhotoMutation) ResetUploadedBy() {
	m.uploaded_by = nil
	m.cleareduploaded_by = false
}

// AddGeneratedIDs adds the "generated" edge to the GeneratedPhoto entity by ids.
func (m *OriginalPhotoMutation) AddGeneratedIDs(ids ...string) {
	if m.generated == nil {
		m.generated = make(map[string]struct{})
	}
	for i := range ids {
		m.generated[ids[i]] = struct{}{}
	}
}

// ClearGenerated clears the "generated" edge to the GeneratedPhoto entity.
func (m *OriginalPhotoMutation) ClearGenerated() {
	m.clearedgenerated = true
}

// GeneratedCleared reports if the "generated" edge to the GeneratedPhoto entity was cleared.
func (m *OriginalPhotoMutation) GeneratedCleared() bool {
	return m.clearedgenerated
}

// RemoveGeneratedIDs removes the "generated" edge to the GeneratedPhoto entity by IDs.
func (m *OriginalPhotoMutation) RemoveGeneratedIDs(ids ...string) {
	if m.removedgenerated == nil {
		m.removedgenerated = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.generated, ids[i])
		m.removedgenerated[ids[i]] = struct{}{}
	}
}

// RemovedGenerated returns the removed IDs of the "generated" edge to the GeneratedPhoto entity.
func (m *OriginalPhotoMutation) RemovedGeneratedIDs() (ids []string) {
	for id := range m.removedgenerated {
		ids = append(ids, id)
	}
	return
}

// GeneratedIDs returns the "generated" edge IDs in the mutation.
func (m *OriginalPhotoMutation) GeneratedIDs() (ids []string) {
	for id := range m.generated {
		ids = append(ids, id)
	}
	return
}

// ResetGenerated resets all changes to the "generated" edge.
func (m *OriginalPhotoMutation) ResetGenerated() {
	m.generated = nil
	m.clearedgenerated = false
	m.removedgenerated = nil
}

// AddCreditUsageIDs adds the "credit_usages" edge to the CreditUsage entity by ids.
func (m *OriginalPhotoMutation) AddCreditUsageIDs(ids ...string) {
	if m.credit_usages == nil {
		m.credit_usages = make(map[string]struct{})
	}
	for i := range ids {
		m.credit_usages[ids[i]] = struct{}{}
	}
}

// ClearCreditUsages clears the "credit_usages" edge to the CreditUsage entity.
func (m *OriginalPhotoMutation) ClearCreditUsages() {
	m.clearedcredit_usages = true
}

// CreditUsagesCleared reports if the "credit_usages" edge to the CreditUsage entity was cleared.
func (m *OriginalPhotoMutation) CreditUsagesCleared() bool {
	return m.clearedcredit_usages
}

// RemoveCreditUsageIDs removes the "credit_usages" edge to the CreditUsage entity by IDs.
func (m *OriginalPhotoMutation) RemoveCreditUsageIDs(ids ...string) {
	if m.removedcredit_usages == nil {
		m.removedcredit_usages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credit_usages, ids[i])
		m.removedcredit_usages[ids[i]] = struct{}{}
	}
}

// RemovedCreditUsages returns the removed IDs of the "credit_usages" edge to the CreditUsage entity.
func (m *OriginalPhotoMutation) RemovedCreditUsagesIDs() (ids []string) {
	for id := range m.removedcredit_usages {
		ids = append(ids, id)
	}
	return
}

// CreditUsagesIDs returns the "credit_usages" edge IDs in the mutation.
func (m *OriginalPhotoMutation) CreditUsagesIDs() (ids []string) {
	for id := range m.credit_usages {
		ids = append(ids, id)
	}
	return
}

// ResetCreditUsages resets all changes to the "credit_usages" edge.
func (m *OriginalPhotoMutation) ResetCreditUsages() {
	m.credit_usages = nil
	m.clearedcredit_usages = false
	m.removedcredit_usages = nil
}

// Where appends a list predicates to the OriginalPhotoMutation builder.
func (m *OriginalPhotoMutation) Where(ps ...predicate.OriginalPhoto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OriginalPhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OriginalPhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OriginalPhoto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OriginalPhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OriginalPhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OriginalPhoto).
func (m *OriginalPhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OriginalPhotoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, originalphoto.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, originalphoto.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, originalphoto.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OriginalPhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case originalphoto.FieldCreatedAt:
		return m.CreatedAt()
	case originalphoto.FieldUpdatedAt:
		return m.UpdatedAt()
	case originalphoto.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OriginalPhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case originalphoto.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case originalphoto.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case originalphoto.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OriginalPhoto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OriginalPhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case originalphoto.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case originalphoto.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case originalphoto.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OriginalPhoto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OriginalPhotoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OriginalPhotoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OriginalPhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OriginalPhoto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OriginalPhotoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(originalphoto.FieldDeletedAt) {
		fields = append(fields, originalphoto.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OriginalPhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OriginalPhotoMutation) ClearField(name string) error {
	switch name {
	case originalphoto.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown OriginalPhoto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OriginalPhotoMutation) ResetField(name string) error {
	switch name {
	case originalphoto.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case originalphoto.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case originalphoto.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown OriginalPhoto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OriginalPhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.album != nil {
		edges = append(edges, originalphoto.EdgeAlbum)
	}
	if m.file != nil {
		edges = append(edges, originalphoto.EdgeFile)
	}
	if m.uploaded_by != nil {
		edges = append(edges, originalphoto.EdgeUploadedBy)
	}
	if m.generated != nil {
		edges = append(edges, originalphoto.EdgeGenerated)
	}
	if m.credit_usages != nil {
		edges = append(edges, originalphoto.EdgeCreditUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OriginalPhotoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case originalphoto.EdgeAlbum:
		if id := m.album; id != nil {
			return []ent.Value{*id}
		}
	case originalphoto.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case originalphoto.EdgeUploadedBy:
		if id := m.uploaded_by; id != nil {
			return []ent.Value{*id}
		}
	case originalphoto.EdgeGenerated:
		ids := make([]ent.Value, 0, len(m.generated))
		for id := range m.generated {
			ids = append(ids, id)
		}
		return ids
	case originalphoto.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.credit_usages))
		for id := range m.credit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OriginalPhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedgenerated != nil {
		edges = append(edges, originalphoto.EdgeGenerated)
	}
	if m.removedcredit_usages != nil {
		edges = append(edges, originalphoto.EdgeCreditUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OriginalPhotoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case originalphoto.EdgeGenerated:
		ids := make([]ent.Value, 0, len(m.removedgenerated))
		for id := range m.removedgenerated {
			ids = append(ids, id)
		}
		return ids
	case originalphoto.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.removedcredit_usages))
		for id := range m.removedcredit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OriginalPhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedalbum {
		edges = append(edges, originalphoto.EdgeAlbum)
	}
	if m.clearedfile {
		edges = append(edges, originalphoto.EdgeFile)
	}
	if m.cleareduploaded_by {
		edges = append(edges, originalphoto.EdgeUploadedBy)
	}
	if m.clearedgenerated {
		edges = append(edges, originalphoto.EdgeGenerated)
	}
	if m.clearedcredit_usages {
		edges = append(edges, originalphoto.EdgeCreditUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OriginalPhotoMutation) EdgeCleared(name string) bool {
	switch name {
	case originalphoto.EdgeAlbum:
		return m.clearedalbum
	case originalphoto.EdgeFile:
		return m.clearedfile
	case originalphoto.EdgeUploadedBy:
		return m.cleareduploaded_by
	case originalphoto.EdgeGenerated:
		return m.clearedgenerated
	case originalphoto.EdgeCreditUsages:
		return m.clearedcredit_usages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OriginalPhotoMutation) ClearEdge(name string) error {
	switch name {
	case originalphoto.EdgeAlbum:
		m.ClearAlbum()
		return nil
	case originalphoto.EdgeFile:
		m.ClearFile()
		return nil
	case originalphoto.EdgeUploadedBy:
		m.ClearUploadedBy()
		return nil
	}
	return fmt.Errorf("unknown OriginalPhoto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OriginalPhotoMutation) ResetEdge(name string) error {
	switch name {
	case originalphoto.EdgeAlbum:
		m.ResetAlbum()
		return nil
	case originalphoto.EdgeFile:
		m.ResetFile()
		return nil
	case originalphoto.EdgeUploadedBy:
		m.ResetUploadedBy()
		return nil
	case originalphoto.EdgeGenerated:
		m.ResetGenerated()
		return nil
	case originalphoto.EdgeCreditUsages:
		m.ResetCreditUsages()
		return nil
	}
	return fmt.Errorf("unknown OriginalPhoto edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	stripe_price_id  *string
	credits          *int
	addcredits       *int
	active           *bool
	unit_amount      *int64
	addunit_amount   *int64
	currency         *string
	clearedFields    map[string]struct{}
	purchases        map[string]struct{}
	removedpurchases map[string]struct{}
	clearedpurchases bool
	done             bool
	oldValue         func(context.Context) (*Price, error)
	predicates       []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id string) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Price entities.
func (m *PriceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PriceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PriceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PriceMutation) ResetName() {
	m.name = nil
}

// SetStripePriceID sets the "stripe_price_id" field.
func (m *PriceMutation) SetStripePriceID(s string) {
	m.stripe_price_id = &s
}

// StripePriceID returns the value of the "stripe_price_id" field in the mutation.
func (m *PriceMutation) StripePriceID() (r string, exists bool) {
	v := m.stripe_price_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripePriceID returns the old "stripe_price_id" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldStripePriceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripePriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripePriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripePriceID: %w", err)
	}
	return oldValue.StripePriceID, nil
}

// ResetStripePriceID resets all changes to the "stripe_price_id" field.
func (m *PriceMutation) ResetStripePriceID() {
	m.stripe_price_id = nil
}

// SetCredits sets the "credits" field.
func (m *PriceMutation) SetCredits(i int) {
	m.credits = &i
	m.addcredits = nil
}

// Credits returns the value of the "credits" field in the mutation.
func (m *PriceMutation) Credits() (r int, exists bool) {
	v := m.credits
	if v == nil {
		return
	}
	return *v, true
}

// OldCredits returns the old "credits" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCredits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredits: %w", err)
	}
	return oldValue.Credits, nil
}

// AddCredits adds i to the "credits" field.
func (m *PriceMutation) AddCredits(i int) {
	if m.addcredits != nil {
		*m.addcredits += i
	} else {
		m.addcredits = &i
	}
}

// AddedCredits returns the value that was added to the "credits" field in this mutation.
func (m *PriceMutation) AddedCredits() (r int, exists bool) {
	v := m.addcredits
	if v == nil {
		return
	}
	return *v, true
}

// ResetCredits resets all changes to the "credits" field.
func (m *PriceMutation) ResetCredits() {
	m.credits = nil
	m.addcredits = nil
}

// SetActive sets the "active" field.
func (m *PriceMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PriceMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PriceMutation) ResetActive() {
	m.active = nil
}

// SetUnitAmount sets the "unit_amount" field.
func (m *PriceMutation) SetUnitAmount(i int64) {
	m.unit_amount = &i
	m.addunit_amount = nil
}

// UnitAmount returns the value of the "unit_amount" field in the mutation.
func (m *PriceMutation) UnitAmount() (r int64, exists bool) {
	v := m.unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAmount returns the old "unit_amount" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUnitAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAmount: %w", err)
	}
	return oldValue.UnitAmount, nil
}

// AddUnitAmount adds i to the "unit_amount" field.
func (m *PriceMutation) AddUnitAmount(i int64) {
	if m.addunit_amount != nil {
		*m.addunit_amount += i
	} else {
		m.addunit_amount = &i
	}
}

// AddedUnitAmount returns the value that was added to the "unit_amount" field in this mutation.
func (m *PriceMutation) AddedUnitAmount() (r int64, exists bool) {
	v := m.addunit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitAmount clears the value of the "unit_amount" field.
func (m *PriceMutation) ClearUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	m.clearedFields[price.FieldUnitAmount] = struct{}{}
}

// UnitAmountCleared returns if the "unit_amount" field was cleared in this mutation.
func (m *PriceMutation) UnitAmountCleared() bool {
	_, ok := m.clearedFields[price.FieldUnitAmount]
	return ok
}

// ResetUnitAmount resets all changes to the "unit_amount" field.
func (m *PriceMutation) ResetUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	delete(m.clearedFields, price.FieldUnitAmount)
}

// SetCurrency sets the "currency" field.
func (m *PriceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PriceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *PriceMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[price.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *PriceMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[price.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PriceMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, price.FieldCurrency)
}

// AddPurchaseIDs adds the "purchases" edge to the Purchase entity by ids.
func (m *PriceMutation) AddPurchaseIDs(ids ...string) {
	if m.purchases == nil {
		m.purchases = make(map[string]struct{})
	}
	for i := range ids {
		m.purchases[ids[i]] = struct{}{}
	}
}

// ClearPurchases clears the "purchases" edge to the Purchase entity.
func (m *PriceMutation) ClearPurchases() {
	m.clearedpurchases = true
}

// PurchasesCleared reports if the "purchases" edge to the Purchase entity was cleared.
func (m *PriceMutation) PurchasesCleared() bool {
	return m.clearedpurchases
}

// RemovePurchaseIDs removes the "purchases" edge to the Purchase entity by IDs.
func (m *PriceMutation) RemovePurchaseIDs(ids ...string) {
	if m.removedpurchases == nil {
		m.removedpurchases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.purchases, ids[i])
		m.removedpurchases[ids[i]] = struct{}{}
	}
}

// RemovedPurchases returns the removed IDs of the "purchases" edge to the Purchase entity.
func (m *PriceMutation) RemovedPurchasesIDs() (ids []string) {
	for id := range m.removedpurchases {
		ids = append(ids, id)
	}
	return
}

// PurchasesIDs returns the "purchases" edge IDs in the mutation.
func (m *PriceMutation) PurchasesIDs() (ids []string) {
	for id := range m.purchases {
		ids = append(ids, id)
	}
	return
}

// ResetPurchases resets all changes to the "purchases" edge.
func (m *PriceMutation) ResetPurchases() {
	m.purchases = nil
	m.clearedpurchases = false
	m.removedpurchases = nil
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, price.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, price.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, price.FieldName)
	}
	if m.stripe_price_id != nil {
		fields = append(fields, price.FieldStripePriceID)
	}
	if m.credits != nil {
		fields = append(fields, price.FieldCredits)
	}
	if m.active != nil {
		fields = append(fields, price.FieldActive)
	}
	if m.unit_amount != nil {
		fields = append(fields, price.FieldUnitAmount)
	}
	if m.currency != nil {
		fields = append(fields, price.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCreatedAt:
		return m.CreatedAt()
	case price.FieldUpdatedAt:
		return m.UpdatedAt()
	case price.FieldName:
		return m.Name()
	case price.FieldStripePriceID:
		return m.StripePriceID()
	case price.FieldCredits:
		return m.Credits()
	case price.FieldActive:
		return m.Active()
	case price.FieldUnitAmount:
		return m.UnitAmount()
	case price.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case price.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case price.FieldName:
		return m.OldName(ctx)
	case price.FieldStripePriceID:
		return m.OldStripePriceID(ctx)
	case price.FieldCredits:
		return m.OldCredits(ctx)
	case price.FieldActive:
		return m.OldActive(ctx)
	case price.FieldUnitAmount:
		return m.OldUnitAmount(ctx)
	case price.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case price.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case price.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case price.FieldStripePriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripePriceID(v)
		return nil
	case price.FieldCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredits(v)
		return nil
	case price.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case price.FieldUnitAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAmount(v)
		return nil
	case price.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	var fields []string
	if m.addcredits != nil {
		fields = append(fields, price.FieldCredits)
	}
	if m.addunit_amount != nil {
		fields = append(fields, price.FieldUnitAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case price.FieldCredits:
		return m.AddedCredits()
	case price.FieldUnitAmount:
		return m.AddedUnitAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case price.FieldCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCredits(v)
		return nil
	case price.FieldUnitAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldUnitAmount) {
		fields = append(fields, price.FieldUnitAmount)
	}
	if m.FieldCleared(price.FieldCurrency) {
		fields = append(fields, price.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldUnitAmount:
		m.ClearUnitAmount()
		return nil
	case price.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case price.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case price.FieldName:
		m.ResetName()
		return nil
	case price.FieldStripePriceID:
		m.ResetStripePriceID()
		return nil
	case price.FieldCredits:
		m.ResetCredits()
		return nil
	case price.FieldActive:
		m.ResetActive()
		return nil
	case price.FieldUnitAmount:
		m.ResetUnitAmount()
		return nil
	case price.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.purchases != nil {
		edges = append(edges, price.EdgePurchases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case price.EdgePurchases:
		ids := make([]ent.Value, 0, len(m.purchases))
		for id := range m.purchases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpurchases != nil {
		edges = append(edges, price.EdgePurchases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case price.EdgePurchases:
		ids := make([]ent.Value, 0, len(m.removedpurchases))
		for id := range m.removedpurchases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpurchases {
		edges = append(edges, price.EdgePurchases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	switch name {
	case price.EdgePurchases:
		return m.clearedpurchases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	switch name {
	case price.EdgePurchases:
		m.ResetPurchases()
		return nil
	}
	return fmt.Errorf("unknown Price edge %s", name)
}

// PurchaseMutation represents an operation that mutates the Purchase nodes in the graph.
type PurchaseMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *time.Time
	updated_at                 *time.Time
	stripe_checkout_session_id *string
	stripe_payment_intent_id   *string
	stripe_customer_id         *string
	amount_total               *int64
	addamount_total            *int64
	currency                   *string
	credits_granted            *int64
	addcredits_granted         *int64
	status                     *purchase.Status
	completed_at               *time.Time
	clearedFields              map[string]struct{}
	user                       *string
	cleareduser                bool
	price                      *string
	clearedprice               bool
	done                       bool
	oldValue                   func(context.Context) (*Purchase, error)
	predicates                 []predicate.Purchase
}

var _ ent.Mutation = (*PurchaseMutation)(nil)

// purchaseOption allows management of the mutation configuration using functional options.
type purchaseOption func(*PurchaseMutation)

// newPurchaseMutation creates new mutation for the Purchase entity.
func newPurchaseMutation(c config, op Op, opts ...purchaseOption) *PurchaseMutation {
	m := &PurchaseMutation{
		config:        c,
		op:            op,
		typ:           TypePurchase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurchaseID sets the ID field of the mutation.
func withPurchaseID(id string) purchaseOption {
	return func(m *PurchaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Purchase
		)
		m.oldValue = func(ctx context.Context) (*Purchase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Purchase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurchase sets the old Purchase of the mutation.
func withPurchase(node *Purchase) purchaseOption {
	return func(m *PurchaseMutation) {
		m.oldValue = func(context.Context) (*Purchase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurchaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurchaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Purchase entities.
func (m *PurchaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PurchaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PurchaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Purchase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PurchaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PurchaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PurchaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PurchaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PurchaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PurchaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStripeCheckoutSessionID sets the "stripe_checkout_session_id" field.
func (m *PurchaseMutation) SetStripeCheckoutSessionID(s string) {
	m.stripe_checkout_session_id = &s
}

// StripeCheckoutSessionID returns the value of the "stripe_checkout_session_id" field in the mutation.
func (m *PurchaseMutation) StripeCheckoutSessionID() (r string, exists bool) {
	v := m.stripe_checkout_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCheckoutSessionID returns the old "stripe_checkout_session_id" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldStripeCheckoutSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCheckoutSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCheckoutSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCheckoutSessionID: %w", err)
	}
	return oldValue.StripeCheckoutSessionID, nil
}

// ResetStripeCheckoutSessionID resets all changes to the "stripe_checkout_session_id" field.
func (m *PurchaseMutation) ResetStripeCheckoutSessionID() {
	m.stripe_checkout_session_id = nil
}

// SetStripePaymentIntentID sets the "stripe_payment_intent_id" field.
func (m *PurchaseMutation) SetStripePaymentIntentID(s string) {
	m.stripe_payment_intent_id = &s
}

// StripePaymentIntentID returns the value of the "stripe_payment_intent_id" field in the mutation.
func (m *PurchaseMutation) StripePaymentIntentID() (r string, exists bool) {
	v := m.stripe_payment_intent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripePaymentIntentID returns the old "stripe_payment_intent_id" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldStripePaymentIntentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripePaymentIntentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripePaymentIntentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripePaymentIntentID: %w", err)
	}
	return oldValue.StripePaymentIntentID, nil
}

// ClearStripePaymentIntentID clears the value of the "stripe_payment_intent_id" field.
func (m *PurchaseMutation) ClearStripePaymentIntentID() {
	m.stripe_payment_intent_id = nil
	m.clearedFields[purchase.FieldStripePaymentIntentID] = struct{}{}
}

// StripePaymentIntentIDCleared returns if the "stripe_payment_intent_id" field was cleared in this mutation.
func (m *PurchaseMutation) StripePaymentIntentIDCleared() bool {
	_, ok := m.clearedFields[purchase.FieldStripePaymentIntentID]
	return ok
}

// ResetStripePaymentIntentID resets all changes to the "stripe_payment_intent_id" field.
func (m *PurchaseMutation) ResetStripePaymentIntentID() {
	m.stripe_payment_intent_id = nil
	delete(m.clearedFields, purchase.FieldStripePaymentIntentID)
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *PurchaseMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *PurchaseMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *PurchaseMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[purchase.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *PurchaseMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[purchase.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *PurchaseMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, purchase.FieldStripeCustomerID)
}

// SetAmountTotal sets the "amount_total" field.
func (m *PurchaseMutation) SetAmountTotal(i int64) {
	m.amount_total = &i
	m.addamount_total = nil
}

// AmountTotal returns the value of the "amount_total" field in the mutation.
func (m *PurchaseMutation) AmountTotal() (r int64, exists bool) {
	v := m.amount_total
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountTotal returns the old "amount_total" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldAmountTotal(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountTotal: %w", err)
	}
	return oldValue.AmountTotal, nil
}

// AddAmountTotal adds i to the "amount_total" field.
func (m *PurchaseMutation) AddAmountTotal(i int64) {
	if m.addamount_total != nil {
		*m.addamount_total += i
	} else {
		m.addamount_total = &i
	}
}

// AddedAmountTotal returns the value that was added to the "amount_total" field in this mutation.
func (m *PurchaseMutation) AddedAmountTotal() (r int64, exists bool) {
	v := m.addamount_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmountTotal clears the value of the "amount_total" field.
func (m *PurchaseMutation) ClearAmountTotal() {
	m.amount_total = nil
	m.addamount_total = nil
	m.clearedFields[purchase.FieldAmountTotal] = struct{}{}
}

// AmountTotalCleared returns if the "amount_total" field was cleared in this mutation.
func (m *PurchaseMutation) AmountTotalCleared() bool {
	_, ok := m.clearedFields[purchase.FieldAmountTotal]
	return ok
}

// ResetAmountTotal resets all changes to the "amount_total" field.
func (m *PurchaseMutation) ResetAmountTotal() {
	m.amount_total = nil
	m.addamount_total = nil
	delete(m.clearedFields, purchase.FieldAmountTotal)
}

// SetCurrency sets the "currency" field.
func (m *PurchaseMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PurchaseMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *PurchaseMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[purchase.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *PurchaseMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[purchase.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PurchaseMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, purchase.FieldCurrency)
}

// SetCreditsGranted sets the "credits_granted" field.
func (m *PurchaseMutation) SetCreditsGranted(i int64) {
	m.credits_granted = &i
	m.addcredits_granted = nil
}

// CreditsGranted returns the value of the "credits_granted" field in the mutation.
func (m *PurchaseMutation) CreditsGranted() (r int64, exists bool) {
	v := m.credits_granted
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditsGranted returns the old "credits_granted" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldCreditsGranted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditsGranted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditsGranted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditsGranted: %w", err)
	}
	return oldValue.CreditsGranted, nil
}

// AddCreditsGranted adds i to the "credits_granted" field.
func (m *PurchaseMutation) AddCreditsGranted(i int64) {
	if m.addcredits_granted != nil {
		*m.addcredits_granted += i
	} else {
		m.addcredits_granted = &i
	}
}

// AddedCreditsGranted returns the value that was added to the "credits_granted" field in this mutation.
func (m *PurchaseMutation) AddedCreditsGranted() (r int64, exists bool) {
	v := m.addcredits_granted
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditsGranted resets all changes to the "credits_granted" field.
func (m *PurchaseMutation) ResetCreditsGranted() {
	m.credits_granted = nil
	m.addcredits_granted = nil
}

// SetStatus sets the "status" field.
func (m *PurchaseMutation) SetStatus(pu purchase.Status) {
	m.status = &pu
}

// Status returns the value of the "status" field in the mutation.
func (m *PurchaseMutation) Status() (r purchase.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldStatus(ctx context.Context) (v purchase.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PurchaseMutation) ResetStatus() {
	m.status = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *PurchaseMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *PurchaseMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *PurchaseMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[purchase.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *PurchaseMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[purchase.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *PurchaseMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, purchase.FieldCompletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PurchaseMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PurchaseMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PurchaseMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PurchaseMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PurchaseMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PurchaseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPriceID sets the "price" edge to the Price entity by id.
func (m *PurchaseMutation) SetPriceID(id string) {
	m.price = &id
}

// ClearPrice clears the "price" edge to the Price entity.
func (m *PurchaseMutation) ClearPrice() {
	m.clearedprice = true
}

// PriceCleared reports if the "price" edge to the Price entity was cleared.
func (m *PurchaseMutation) PriceCleared() bool {
	return m.clearedprice
}

// PriceID returns the "price" edge ID in the mutation.
func (m *PurchaseMutation) PriceID() (id string, exists bool) {
	if m.price != nil {
		return *m.price, true
	}
	return
}

// PriceIDs returns the "price" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PriceID instead. It exists only for internal usage by the builders.
func (m *PurchaseMutation) PriceIDs() (ids []string) {
	if id := m.price; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrice resets all changes to the "price" edge.
func (m *PurchaseMutation) ResetPrice() {
	m.price = nil
	m.clearedprice = false
}

// Where appends a list predicates to the PurchaseMutation builder.
func (m *PurchaseMutation) Where(ps ...predicate.Purchase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PurchaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PurchaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Purchase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PurchaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PurchaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Purchase).
func (m *PurchaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PurchaseMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, purchase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, purchase.FieldUpdatedAt)
	}
	if m.stripe_checkout_session_id != nil {
		fields = append(fields, purchase.FieldStripeCheckoutSessionID)
	}
	if m.stripe_payment_intent_id != nil {
		fields = append(fields, purchase.FieldStripePaymentIntentID)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, purchase.FieldStripeCustomerID)
	}
	if m.amount_total != nil {
		fields = append(fields, purchase.FieldAmountTotal)
	}
	if m.currency != nil {
		fields = append(fields, purchase.FieldCurrency)
	}
	if m.credits_granted != nil {
		fields = append(fields, purchase.FieldCreditsGranted)
	}
	if m.status != nil {
		fields = append(fields, purchase.FieldStatus)
	}
	if m.completed_at != nil {
		fields = append(fields, purchase.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PurchaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purchase.FieldCreatedAt:
		return m.CreatedAt()
	case purchase.FieldUpdatedAt:
		return m.UpdatedAt()
	case purchase.FieldStripeCheckoutSessionID:
		return m.StripeCheckoutSessionID()
	case purchase.FieldStripePaymentIntentID:
		return m.StripePaymentIntentID()
	case purchase.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case purchase.FieldAmountTotal:
		return m.AmountTotal()
	case purchase.FieldCurrency:
		return m.Currency()
	case purchase.FieldCreditsGranted:
		return m.CreditsGranted()
	case purchase.FieldStatus:
		return m.Status()
	case purchase.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PurchaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purchase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case purchase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case purchase.FieldStripeCheckoutSessionID:
		return m.OldStripeCheckoutSessionID(ctx)
	case purchase.FieldStripePaymentIntentID:
		return m.OldStripePaymentIntentID(ctx)
	case purchase.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case purchase.FieldAmountTotal:
		return m.OldAmountTotal(ctx)
	case purchase.FieldCurrency:
		return m.OldCurrency(ctx)
	case purchase.FieldCreditsGranted:
		return m.OldCreditsGranted(ctx)
	case purchase.FieldStatus:
		return m.OldStatus(ctx)
	case purchase.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Purchase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purchase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case purchase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case purchase.FieldStripeCheckoutSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCheckoutSessionID(v)
		return nil
	case purchase.FieldStripePaymentIntentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripePaymentIntentID(v)
		return nil
	case purchase.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case purchase.FieldAmountTotal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountTotal(v)
		return nil
	case purchase.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case purchase.FieldCreditsGranted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditsGranted(v)
		return nil
	case purchase.FieldStatus:
		v, ok := value.(purchase.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case purchase.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Purchase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PurchaseMutation) AddedFields() []string {
	var fields []string
	if m.addamount_total != nil {
		fields = append(fields, purchase.FieldAmountTotal)
	}
	if m.addcredits_granted != nil {
		fields = append(fields, purchase.FieldCreditsGranted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PurchaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case purchase.FieldAmountTotal:
		return m.AddedAmountTotal()
	case purchase.FieldCreditsGranted:
		return m.AddedCreditsGranted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case purchase.FieldAmountTotal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountTotal(v)
		return nil
	case purchase.FieldCreditsGranted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditsGranted(v)
		return nil
	}
	return fmt.Errorf("unknown Purchase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PurchaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(purchase.FieldStripePaymentIntentID) {
		fields = append(fields, purchase.FieldStripePaymentIntentID)
	}
	if m.FieldCleared(purchase.FieldStripeCustomerID) {
		fields = append(fields, purchase.FieldStripeCustomerID)
	}
	if m.FieldCleared(purchase.FieldAmountTotal) {
		fields = append(fields, purchase.FieldAmountTotal)
	}
	if m.FieldCleared(purchase.FieldCurrency) {
		fields = append(fields, purchase.FieldCurrency)
	}
	if m.FieldCleared(purchase.FieldCompletedAt) {
		fields = append(fields, purchase.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PurchaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurchaseMutation) ClearField(name string) error {
	switch name {
	case purchase.FieldStripePaymentIntentID:
		m.ClearStripePaymentIntentID()
		return nil
	case purchase.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case purchase.FieldAmountTotal:
		m.ClearAmountTotal()
		return nil
	case purchase.FieldCurrency:
		m.ClearCurrency()
		return nil
	case purchase.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Purchase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PurchaseMutation) ResetField(name string) error {
	switch name {
	case purchase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case purchase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case purchase.FieldStripeCheckoutSessionID:
		m.ResetStripeCheckoutSessionID()
		return nil
	case purchase.FieldStripePaymentIntentID:
		m.ResetStripePaymentIntentID()
		return nil
	case purchase.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case purchase.FieldAmountTotal:
		m.ResetAmountTotal()
		return nil
	case purchase.FieldCurrency:
		m.ResetCurrency()
		return nil
	case purchase.FieldCreditsGranted:
		m.ResetCreditsGranted()
		return nil
	case purchase.FieldStatus:
		m.ResetStatus()
		return nil
	case purchase.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Purchase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PurchaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, purchase.EdgeUser)
	}
	if m.price != nil {
		edges = append(edges, purchase.EdgePrice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PurchaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purchase.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case purchase.EdgePrice:
		if id := m.price; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PurchaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PurchaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PurchaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, purchase.EdgeUser)
	}
	if m.clearedprice {
		edges = append(edges, purchase.EdgePrice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PurchaseMutation) EdgeCleared(name string) bool {
	switch name {
	case purchase.EdgeUser:
		return m.cleareduser
	case purchase.EdgePrice:
		return m.clearedprice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PurchaseMutation) ClearEdge(name string) error {
	switch name {
	case purchase.EdgeUser:
		m.ClearUser()
		return nil
	case purchase.EdgePrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown Purchase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PurchaseMutation) ResetEdge(name string) error {
	switch name {
	case purchase.EdgeUser:
		m.ResetUser()
		return nil
	case purchase.EdgePrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Purchase edge %s", name)
}

// ThemeMutation represents an operation that mutates the Theme nodes in the graph.
type ThemeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	slug                 *string
	prompt               *string
	clearedFields        map[string]struct{}
	created_by           *string
	clearedcreated_by    bool
	albums               map[string]struct{}
	removedalbums        map[string]struct{}
	clearedalbums        bool
	generated            map[string]struct{}
	removedgenerated     map[string]struct{}
	clearedgenerated     bool
	credit_usages        map[string]struct{}
	removedcredit_usages map[string]struct{}
	clearedcredit_usages bool
	done                 bool
	oldValue             func(context.Context) (*Theme, error)
	predicates           []predicate.Theme
}

var _ ent.Mutation = (*ThemeMutation)(nil)

// themeOption allows management of the mutation configuration using functional options.
type themeOption func(*ThemeMutation)

// newThemeMutation creates new mutation for the Theme entity.
func newThemeMutation(c config, op Op, opts ...themeOption) *ThemeMutation {
	m := &ThemeMutation{
		config:        c,
		op:            op,
		typ:           TypeTheme,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThemeID sets the ID field of the mutation.
func withThemeID(id string) themeOption {
	return func(m *ThemeMutation) {
		var (
			err   error
			once  sync.Once
			value *Theme
		)
		m.oldValue = func(ctx context.Context) (*Theme, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Theme.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTheme sets the old Theme of the mutation.
func withTheme(node *Theme) themeOption {
	return func(m *ThemeMutation) {
		m.oldValue = func(context.Context) (*Theme, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThemeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThemeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Theme entities.
func (m *ThemeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThemeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThemeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Theme.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThemeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThemeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThemeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThemeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThemeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThemeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ThemeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ThemeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ThemeMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *ThemeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ThemeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ThemeMutation) ResetSlug() {
	m.slug = nil
}

// SetPrompt sets the "prompt" field.
func (m *ThemeMutation) SetPrompt(s string) {
	m.prompt = &s
}

// Prompt returns the value of the "prompt" field in the mutation.
func (m *ThemeMutation) Prompt() (r string, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPrompt returns the old "prompt" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldPrompt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrompt: %w", err)
	}
	return oldValue.Prompt, nil
}

// ResetPrompt resets all changes to the "prompt" field.
func (m *ThemeMutation) ResetPrompt() {
	m.prompt = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ThemeMutation) SetCreatedByID(id string) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ThemeMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ThemeMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ThemeMutation) CreatedByID() (id string, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ThemeMutation) CreatedByIDs() (ids []string) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ThemeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *ThemeMutation) AddAlbumIDs(ids ...string) {
	if m.albums == nil {
		m.albums = make(map[string]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *ThemeMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *ThemeMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *ThemeMutation) RemoveAlbumIDs(ids ...string) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *ThemeMutation) RemovedAlbumsIDs() (ids []string) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *ThemeMutation) AlbumsIDs() (ids []string) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *ThemeMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// AddGeneratedIDs adds the "generated" edge to the GeneratedPhoto entity by ids.
func (m *ThemeMutation) AddGeneratedIDs(ids ...string) {
	if m.generated == nil {
		m.generated = make(map[string]struct{})
	}
	for i := range ids {
		m.generated[ids[i]] = struct{}{}
	}
}

// ClearGenerated clears the "generated" edge to the GeneratedPhoto entity.
func (m *ThemeMutation) ClearGenerated() {
	m.clearedgenerated = true
}

// GeneratedCleared reports if the "generated" edge to the GeneratedPhoto entity was cleared.
func (m *ThemeMutation) GeneratedCleared() bool {
	return m.clearedgenerated
}

// RemoveGeneratedIDs removes the "generated" edge to the GeneratedPhoto entity by IDs.
func (m *ThemeMutation) RemoveGeneratedIDs(ids ...string) {
	if m.removedgenerated == nil {
		m.removedgenerated = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.generated, ids[i])
		m.removedgenerated[ids[i]] = struct{}{}
	}
}

// RemovedGenerated returns the removed IDs of the "generated" edge to the GeneratedPhoto entity.
func (m *ThemeMutation) RemovedGeneratedIDs() (ids []string) {
	for id := range m.removedgenerated {
		ids = append(ids, id)
	}
	return
}

// GeneratedIDs returns the "generated" edge IDs in the mutation.
func (m *ThemeMutation) GeneratedIDs() (ids []string) {
	for id := range m.generated {
		ids = append(ids, id)
	}
	return
}

// ResetGenerated resets all changes to the "generated" edge.
func (m *ThemeMutation) ResetGenerated() {
	m.generated = nil
	m.clearedgenerated = false
	m.removedgenerated = nil
}

// AddCreditUsageIDs adds the "credit_usages" edge to the CreditUsage entity by ids.
func (m *ThemeMutation) AddCreditUsageIDs(ids ...string) {
	if m.credit_usages == nil {
		m.credit_usages = make(map[string]struct{})
	}
	for i := range ids {
		m.credit_usages[ids[i]] = struct{}{}
	}
}

// ClearCreditUsages clears the "credit_usages" edge to the CreditUsage entity.
func (m *ThemeMutation) ClearCreditUsages() {
	m.clearedcredit_usages = true
}

// CreditUsagesCleared reports if the "credit_usages" edge to the CreditUsage entity was cleared.
func (m *ThemeMutation) CreditUsagesCleared() bool {
	return m.clearedcredit_usages
}

// RemoveCreditUsageIDs removes the "credit_usages" edge to the CreditUsage entity by IDs.
func (m *ThemeMutation) RemoveCreditUsageIDs(ids ...string) {
	if m.removedcredit_usages == nil {
		m.removedcredit_usages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credit_usages, ids[i])
		m.removedcredit_usages[ids[i]] = struct{}{}
	}
}

// RemovedCreditUsages returns the removed IDs of the "credit_usages" edge to the CreditUsage entity.
func (m *ThemeMutation) RemovedCreditUsagesIDs() (ids []string) {
	for id := range m.removedcredit_usages {
		ids = append(ids, id)
	}
	return
}

// CreditUsagesIDs returns the "credit_usages" edge IDs in the mutation.
func (m *ThemeMutation) CreditUsagesIDs() (ids []string) {
	for id := range m.credit_usages {
		ids = append(ids, id)
	}
	return
}

// ResetCreditUsages resets all changes to the "credit_usages" edge.
func (m *ThemeMutation) ResetCreditUsages() {
	m.credit_usages = nil
	m.clearedcredit_usages = false
	m.removedcredit_usages = nil
}

// Where appends a list predicates to the ThemeMutation builder.
func (m *ThemeMutation) Where(ps ...predicate.Theme) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThemeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThemeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Theme, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThemeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThemeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Theme).
func (m *ThemeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThemeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, theme.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, theme.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, theme.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, theme.FieldSlug)
	}
	if m.prompt != nil {
		fields = append(fields, theme.FieldPrompt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThemeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case theme.FieldCreatedAt:
		return m.CreatedAt()
	case theme.FieldUpdatedAt:
		return m.UpdatedAt()
	case theme.FieldName:
		return m.Name()
	case theme.FieldSlug:
		return m.Slug()
	case theme.FieldPrompt:
		return m.Prompt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThemeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case theme.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case theme.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case theme.FieldName:
		return m.OldName(ctx)
	case theme.FieldSlug:
		return m.OldSlug(ctx)
	case theme.FieldPrompt:
		return m.OldPrompt(ctx)
	}
	return nil, fmt.Errorf("unknown Theme field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case theme.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case theme.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case theme.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case theme.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case theme.FieldPrompt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrompt(v)
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThemeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThemeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Theme numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThemeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThemeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThemeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Theme nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThemeMutation) ResetField(name string) error {
	switch name {
	case theme.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case theme.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case theme.FieldName:
		m.ResetName()
		return nil
	case theme.FieldSlug:
		m.ResetSlug()
		return nil
	case theme.FieldPrompt:
		m.ResetPrompt()
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThemeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.created_by != nil {
		edges = append(edges, theme.EdgeCreatedBy)
	}
	if m.albums != nil {
		edges = append(edges, theme.EdgeAlbums)
	}
	if m.generated != nil {
		edges = append(edges, theme.EdgeGenerated)
	}
	if m.credit_usages != nil {
		edges = append(edges, theme.EdgeCreditUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThemeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case theme.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case theme.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	case theme.EdgeGenerated:
		ids := make([]ent.Value, 0, len(m.generated))
		for id := range m.generated {
			ids = append(ids, id)
		}
		return ids
	case theme.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.credit_usages))
		for id := range m.credit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThemeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedalbums != nil {
		edges = append(edges, theme.EdgeAlbums)
	}
	if m.removedgenerated != nil {
		edges = append(edges, theme.EdgeGenerated)
	}
	if m.removedcredit_usages != nil {
		edges = append(edges, theme.EdgeCreditUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThemeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case theme.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	case theme.EdgeGenerated:
		ids := make([]ent.Value, 0, len(m.removedgenerated))
		for id := range m.removedgenerated {
			ids = append(ids, id)
		}
		return ids
	case theme.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.removedcredit_usages))
		for id := range m.removedcredit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThemeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreated_by {
		edges = append(edges, theme.EdgeCreatedBy)
	}
	if m.clearedalbums {
		edges = append(edges, theme.EdgeAlbums)
	}
	if m.clearedgenerated {
		edges = append(edges, theme.EdgeGenerated)
	}
	if m.clearedcredit_usages {
		edges = append(edges, theme.EdgeCreditUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThemeMutation) EdgeCleared(name string) bool {
	switch name {
	case theme.EdgeCreatedBy:
		return m.clearedcreated_by
	case theme.EdgeAlbums:
		return m.clearedalbums
	case theme.EdgeGenerated:
		return m.clearedgenerated
	case theme.EdgeCreditUsages:
		return m.clearedcredit_usages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThemeMutation) ClearEdge(name string) error {
	switch name {
	case theme.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Theme unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThemeMutation) ResetEdge(name string) error {
	switch name {
	case theme.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case theme.EdgeAlbums:
		m.ResetAlbums()
		return nil
	case theme.EdgeGenerated:
		m.ResetGenerated()
		return nil
	case theme.EdgeCreditUsages:
		m.ResetCreditUsages()
		return nil
	}
	return fmt.Errorf("unknown Theme edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	created_at                   *time.Time
	updated_at                   *time.Time
	email                        *string
	name                         *string
	stripe_customer_id           *string
	plan                         *string
	credits                      *int64
	addcredits                   *int64
	clearedFields                map[string]struct{}
	albums                       map[string]struct{}
	removedalbums                map[string]struct{}
	clearedalbums                bool
	memberships                  map[int]struct{}
	removedmemberships           map[int]struct{}
	clearedmemberships           bool
	created_invite_links         map[string]struct{}
	removedcreated_invite_links  map[string]struct{}
	clearedcreated_invite_links  bool
	revoked_invite_links         map[string]struct{}
	removedrevoked_invite_links  map[string]struct{}
	clearedrevoked_invite_links  bool
	created_email_invites        map[string]struct{}
	removedcreated_email_invites map[string]struct{}
	clearedcreated_email_invites bool
	uploaded_photos              map[string]struct{}
	removeduploaded_photos       map[string]struct{}
	cleareduploaded_photos       bool
	themes                       map[string]struct{}
	removedthemes                map[string]struct{}
	clearedthemes                bool
	purchases                    map[string]struct{}
	removedpurchases             map[string]struct{}
	clearedpurchases             bool
	credit_usages                map[string]struct{}
	removedcredit_usages         map[string]struct{}
	clearedcredit_usages         bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *UserMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[user.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *UserMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, user.FieldStripeCustomerID)
}

// SetPlan sets the "plan" field.
func (m *UserMutation) SetPlan(s string) {
	m.plan = &s
}

// Plan returns the value of the "plan" field in the mutation.
func (m *UserMutation) Plan() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlan returns the old "plan" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlan: %w", err)
	}
	return oldValue.Plan, nil
}

// ResetPlan resets all changes to the "plan" field.
func (m *UserMutation) ResetPlan() {
	m.plan = nil
}

// SetCredits sets the "credits" field.
func (m *UserMutation) SetCredits(i int64) {
	m.credits = &i
	m.addcredits = nil
}

// Credits returns the value of the "credits" field in the mutation.
func (m *UserMutation) Credits() (r int64, exists bool) {
	v := m.credits
	if v == nil {
		return
	}
	return *v, true
}

// OldCredits returns the old "credits" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCredits(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredits: %w", err)
	}
	return oldValue.Credits, nil
}

// AddCredits adds i to the "credits" field.
func (m *UserMutation) AddCredits(i int64) {
	if m.addcredits != nil {
		*m.addcredits += i
	} else {
		m.addcredits = &i
	}
}

// AddedCredits returns the value that was added to the "credits" field in this mutation.
func (m *UserMutation) AddedCredits() (r int64, exists bool) {
	v := m.addcredits
	if v == nil {
		return
	}
	return *v, true
}

// ResetCredits resets all changes to the "credits" field.
func (m *UserMutation) ResetCredits() {
	m.credits = nil
	m.addcredits = nil
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *UserMutation) AddAlbumIDs(ids ...string) {
	if m.albums == nil {
		m.albums = make(map[string]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *UserMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *UserMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *UserMutation) RemoveAlbumIDs(ids ...string) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *UserMutation) RemovedAlbumsIDs() (ids []string) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *UserMutation) AlbumsIDs() (ids []string) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *UserMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// AddMembershipIDs adds the "memberships" edge to the AlbumUser entity by ids.
func (m *UserMutation) AddMembershipIDs(ids ...int) {
	if m.memberships == nil {
		m.memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the AlbumUser entity.
func (m *UserMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the AlbumUser entity was cleared.
func (m *UserMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the AlbumUser entity by IDs.
func (m *UserMutation) RemoveMembershipIDs(ids ...int) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the AlbumUser entity.
func (m *UserMutation) RemovedMembershipsIDs() (ids []int) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *UserMutation) MembershipsIDs() (ids []int) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *UserMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddCreatedInviteLinkIDs adds the "created_invite_links" edge to the AlbumInviteLink entity by ids.
func (m *UserMutation) AddCreatedInviteLinkIDs(ids ...string) {
	if m.created_invite_links == nil {
		m.created_invite_links = make(map[string]struct{})
	}
	for i := range ids {
		m.created_invite_links[ids[i]] = struct{}{}
	}
}

// ClearCreatedInviteLinks clears the "created_invite_links" edge to the AlbumInviteLink entity.
func (m *UserMutation) ClearCreatedInviteLinks() {
	m.clearedcreated_invite_links = true
}

// CreatedInviteLinksCleared reports if the "created_invite_links" edge to the AlbumInviteLink entity was cleared.
func (m *UserMutation) CreatedInviteLinksCleared() bool {
	return m.clearedcreated_invite_links
}

// RemoveCreatedInviteLinkIDs removes the "created_invite_links" edge to the AlbumInviteLink entity by IDs.
func (m *UserMutation) RemoveCreatedInviteLinkIDs(ids ...string) {
	if m.removedcreated_invite_links == nil {
		m.removedcreated_invite_links = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_invite_links, ids[i])
		m.removedcreated_invite_links[ids[i]] = struct{}{}
	}
}

// RemovedCreatedInviteLinks returns the removed IDs of the "created_invite_links" edge to the AlbumInviteLink entity.
func (m *UserMutation) RemovedCreatedInviteLinksIDs() (ids []string) {
	for id := range m.removedcreated_invite_links {
		ids = append(ids, id)
	}
	return
}

// CreatedInviteLinksIDs returns the "created_invite_links" edge IDs in the mutation.
func (m *UserMutation) CreatedInviteLinksIDs() (ids []string) {
	for id := range m.created_invite_links {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedInviteLinks resets all changes to the "created_invite_links" edge.
func (m *UserMutation) ResetCreatedInviteLinks() {
	m.created_invite_links = nil
	m.clearedcreated_invite_links = false
	m.removedcreated_invite_links = nil
}

// AddRevokedInviteLinkIDs adds the "revoked_invite_links" edge to the AlbumInviteLink entity by ids.
func (m *UserMutation) AddRevokedInviteLinkIDs(ids ...string) {
	if m.revoked_invite_links == nil {
		m.revoked_invite_links = make(map[string]struct{})
	}
	for i := range ids {
		m.revoked_invite_links[ids[i]] = struct{}{}
	}
}

// ClearRevokedInviteLinks clears the "revoked_invite_links" edge to the AlbumInviteLink entity.
func (m *UserMutation) ClearRevokedInviteLinks() {
	m.clearedrevoked_invite_links = true
}

// RevokedInviteLinksCleared reports if the "revoked_invite_links" edge to the AlbumInviteLink entity was cleared.
func (m *UserMutation) RevokedInviteLinksCleared() bool {
	return m.clearedrevoked_invite_links
}

// RemoveRevokedInviteLinkIDs removes the "revoked_invite_links" edge to the AlbumInviteLink entity by IDs.
func (m *UserMutation) RemoveRevokedInviteLinkIDs(ids ...string) {
	if m.removedrevoked_invite_links == nil {
		m.removedrevoked_invite_links = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.revoked_invite_links, ids[i])
		m.removedrevoked_invite_links[ids[i]] = struct{}{}
	}
}

// RemovedRevokedInviteLinks returns the removed IDs of the "revoked_invite_links" edge to the AlbumInviteLink entity.
func (m *UserMutation) RemovedRevokedInviteLinksIDs() (ids []string) {
	for id := range m.removedrevoked_invite_links {
		ids = append(ids, id)
	}
	return
}

// RevokedInviteLinksIDs returns the "revoked_invite_links" edge IDs in the mutation.
func (m *UserMutation) RevokedInviteLinksIDs() (ids []string) {
	for id := range m.revoked_invite_links {
		ids = append(ids, id)
	}
	return
}

// ResetRevokedInviteLinks resets all changes to the "revoked_invite_links" edge.
func (m *UserMutation) ResetRevokedInviteLinks() {
	m.revoked_invite_links = nil
	m.clearedrevoked_invite_links = false
	m.removedrevoked_invite_links = nil
}

// AddCreatedEmailInviteIDs adds the "created_email_invites" edge to the AlbumInvite entity by ids.
func (m *UserMutation) AddCreatedEmailInviteIDs(ids ...string) {
	if m.created_email_invites == nil {
		m.created_email_invites = make(map[string]struct{})
	}
	for i := range ids {
		m.created_email_invites[ids[i]] = struct{}{}
	}
}

// ClearCreatedEmailInvites clears the "created_email_invites" edge to the AlbumInvite entity.
func (m *UserMutation) ClearCreatedEmailInvites() {
	m.clearedcreated_email_invites = true
}

// CreatedEmailInvitesCleared reports if the "created_email_invites" edge to the AlbumInvite entity was cleared.
func (m *UserMutation) CreatedEmailInvitesCleared() bool {
	return m.clearedcreated_email_invites
}

// RemoveCreatedEmailInviteIDs removes the "created_email_invites" edge to the AlbumInvite entity by IDs.
func (m *UserMutation) RemoveCreatedEmailInviteIDs(ids ...string) {
	if m.removedcreated_email_invites == nil {
		m.removedcreated_email_invites = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_email_invites, ids[i])
		m.removedcreated_email_invites[ids[i]] = struct{}{}
	}
}

// RemovedCreatedEmailInvites returns the removed IDs of the "created_email_invites" edge to the AlbumInvite entity.
func (m *UserMutation) RemovedCreatedEmailInvitesIDs() (ids []string) {
	for id := range m.removedcreated_email_invites {
		ids = append(ids, id)
	}
	return
}

// CreatedEmailInvitesIDs returns the "created_email_invites" edge IDs in the mutation.
func (m *UserMutation) CreatedEmailInvitesIDs() (ids []string) {
	for id := range m.created_email_invites {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedEmailInvites resets all changes to the "created_email_invites" edge.
func (m *UserMutation) ResetCreatedEmailInvites() {
	m.created_email_invites = nil
	m.clearedcreated_email_invites = false
	m.removedcreated_email_invites = nil
}

// AddUploadedPhotoIDs adds the "uploaded_photos" edge to the OriginalPhoto entity by ids.
func (m *UserMutation) AddUploadedPhotoIDs(ids ...string) {
	if m.uploaded_photos == nil {
		m.uploaded_photos = make(map[string]struct{})
	}
	for i := range ids {
		m.uploaded_photos[ids[i]] = struct{}{}
	}
}

// ClearUploadedPhotos clears the "uploaded_photos" edge to the OriginalPhoto entity.
func (m *UserMutation) ClearUploadedPhotos() {
	m.cleareduploaded_photos = true
}

// UploadedPhotosCleared reports if the "uploaded_photos" edge to the OriginalPhoto entity was cleared.
func (m *UserMutation) UploadedPhotosCleared() bool {
	return m.cleareduploaded_photos
}

// RemoveUploadedPhotoIDs removes the "uploaded_photos" edge to the OriginalPhoto entity by IDs.
func (m *UserMutation) RemoveUploadedPhotoIDs(ids ...string) {
	if m.removeduploaded_photos == nil {
		m.removeduploaded_photos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.uploaded_photos, ids[i])
		m.removeduploaded_photos[ids[i]] = struct{}{}
	}
}

// RemovedUploadedPhotos returns the removed IDs of the "uploaded_photos" edge to the OriginalPhoto entity.
func (m *UserMutation) RemovedUploadedPhotosIDs() (ids []string) {
	for id := range m.removeduploaded_photos {
		ids = append(ids, id)
	}
	return
}

// UploadedPhotosIDs returns the "uploaded_photos" edge IDs in the mutation.
func (m *UserMutation) UploadedPhotosIDs() (ids []string) {
	for id := range m.uploaded_photos {
		ids = append(ids, id)
	}
	return
}

// ResetUploadedPhotos resets all changes to the "uploaded_photos" edge.
func (m *UserMutation) ResetUploadedPhotos() {
	m.uploaded_photos = nil
	m.cleareduploaded_photos = false
	m.removeduploaded_photos = nil
}

// AddThemeIDs adds the "themes" edge to the Theme entity by ids.
func (m *UserMutation) AddThemeIDs(ids ...string) {
	if m.themes == nil {
		m.themes = make(map[string]struct{})
	}
	for i := range ids {
		m.themes[ids[i]] = struct{}{}
	}
}

// ClearThemes clears the "themes" edge to the Theme entity.
func (m *UserMutation) ClearThemes() {
	m.clearedthemes = true
}

// ThemesCleared reports if the "themes" edge to the Theme entity was cleared.
func (m *UserMutation) ThemesCleared() bool {
	return m.clearedthemes
}

// RemoveThemeIDs removes the "themes" edge to the Theme entity by IDs.
func (m *UserMutation) RemoveThemeIDs(ids ...string) {
	if m.removedthemes == nil {
		m.removedthemes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.themes, ids[i])
		m.removedthemes[ids[i]] = struct{}{}
	}
}

// RemovedThemes returns the removed IDs of the "themes" edge to the Theme entity.
func (m *UserMutation) RemovedThemesIDs() (ids []string) {
	for id := range m.removedthemes {
		ids = append(ids, id)
	}
	return
}

// ThemesIDs returns the "themes" edge IDs in the mutation.
func (m *UserMutation) ThemesIDs() (ids []string) {
	for id := range m.themes {
		ids = append(ids, id)
	}
	return
}

// ResetThemes resets all changes to the "themes" edge.
func (m *UserMutation) ResetThemes() {
	m.themes = nil
	m.clearedthemes = false
	m.removedthemes = nil
}

// AddPurchaseIDs adds the "purchases" edge to the Purchase entity by ids.
func (m *UserMutation) AddPurchaseIDs(ids ...string) {
	if m.purchases == nil {
		m.purchases = make(map[string]struct{})
	}
	for i := range ids {
		m.purchases[ids[i]] = struct{}{}
	}
}

// ClearPurchases clears the "purchases" edge to the Purchase entity.
func (m *UserMutation) ClearPurchases() {
	m.clearedpurchases = true
}

// PurchasesCleared reports if the "purchases" edge to the Purchase entity was cleared.
func (m *UserMutation) PurchasesCleared() bool {
	return m.clearedpurchases
}

// RemovePurchaseIDs removes the "purchases" edge to the Purchase entity by IDs.
func (m *UserMutation) RemovePurchaseIDs(ids ...string) {
	if m.removedpurchases == nil {
		m.removedpurchases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.purchases, ids[i])
		m.removedpurchases[ids[i]] = struct{}{}
	}
}

// RemovedPurchases returns the removed IDs of the "purchases" edge to the Purchase entity.
func (m *UserMutation) RemovedPurchasesIDs() (ids []string) {
	for id := range m.removedpurchases {
		ids = append(ids, id)
	}
	return
}

// PurchasesIDs returns the "purchases" edge IDs in the mutation.
func (m *UserMutation) PurchasesIDs() (ids []string) {
	for id := range m.purchases {
		ids = append(ids, id)
	}
	return
}

// ResetPurchases resets all changes to the "purchases" edge.
func (m *UserMutation) ResetPurchases() {
	m.purchases = nil
	m.clearedpurchases = false
	m.removedpurchases = nil
}

// AddCreditUsageIDs adds the "credit_usages" edge to the CreditUsage entity by ids.
func (m *UserMutation) AddCreditUsageIDs(ids ...string) {
	if m.credit_usages == nil {
		m.credit_usages = make(map[string]struct{})
	}
	for i := range ids {
		m.credit_usages[ids[i]] = struct{}{}
	}
}

// ClearCreditUsages clears the "credit_usages" edge to the CreditUsage entity.
func (m *UserMutation) ClearCreditUsages() {
	m.clearedcredit_usages = true
}

// CreditUsagesCleared reports if the "credit_usages" edge to the CreditUsage entity was cleared.
func (m *UserMutation) CreditUsagesCleared() bool {
	return m.clearedcredit_usages
}

// RemoveCreditUsageIDs removes the "credit_usages" edge to the CreditUsage entity by IDs.
func (m *UserMutation) RemoveCreditUsageIDs(ids ...string) {
	if m.removedcredit_usages == nil {
		m.removedcredit_usages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credit_usages, ids[i])
		m.removedcredit_usages[ids[i]] = struct{}{}
	}
}

// RemovedCreditUsages returns the removed IDs of the "credit_usages" edge to the CreditUsage entity.
func (m *UserMutation) RemovedCreditUsagesIDs() (ids []string) {
	for id := range m.removedcredit_usages {
		ids = append(ids, id)
	}
	return
}

// CreditUsagesIDs returns the "credit_usages" edge IDs in the mutation.
func (m *UserMutation) CreditUsagesIDs() (ids []string) {
	for id := range m.credit_usages {
		ids = append(ids, id)
	}
	return
}

// ResetCreditUsages resets all changes to the "credit_usages" edge.
func (m *UserMutation) ResetCreditUsages() {
	m.credit_usages = nil
	m.clearedcredit_usages = false
	m.removedcredit_usages = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.plan != nil {
		fields = append(fields, user.FieldPlan)
	}
	if m.credits != nil {
		fields = append(fields, user.FieldCredits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldPlan:
		return m.Plan()
	case user.FieldCredits:
		return m.Credits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldPlan:
		return m.OldPlan(ctx)
	case user.FieldCredits:
		return m.OldCredits(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlan(v)
		return nil
	case user.FieldCredits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredits(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcredits != nil {
		fields = append(fields, user.FieldCredits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCredits:
		return m.AddedCredits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCredits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCredits(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldStripeCustomerID) {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldPlan:
		m.ResetPlan()
		return nil
	case user.FieldCredits:
		m.ResetCredits()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.albums != nil {
		edges = append(edges, user.EdgeAlbums)
	}
	if m.memberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.created_invite_links != nil {
		edges = append(edges, user.EdgeCreatedInviteLinks)
	}
	if m.revoked_invite_links != nil {
		edges = append(edges, user.EdgeRevokedInviteLinks)
	}
	if m.created_email_invites != nil {
		edges = append(edges, user.EdgeCreatedEmailInvites)
	}
	if m.uploaded_photos != nil {
		edges = append(edges, user.EdgeUploadedPhotos)
	}
	if m.themes != nil {
		edges = append(edges, user.EdgeThemes)
	}
	if m.purchases != nil {
		edges = append(edges, user.EdgePurchases)
	}
	if m.credit_usages != nil {
		edges = append(edges, user.EdgeCreditUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedInviteLinks:
		ids := make([]ent.Value, 0, len(m.created_invite_links))
		for id := range m.created_invite_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRevokedInviteLinks:
		ids := make([]ent.Value, 0, len(m.revoked_invite_links))
		for id := range m.revoked_invite_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEmailInvites:
		ids := make([]ent.Value, 0, len(m.created_email_invites))
		for id := range m.created_email_invites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUploadedPhotos:
		ids := make([]ent.Value, 0, len(m.uploaded_photos))
		for id := range m.uploaded_photos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThemes:
		ids := make([]ent.Value, 0, len(m.themes))
		for id := range m.themes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePurchases:
		ids := make([]ent.Value, 0, len(m.purchases))
		for id := range m.purchases {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.credit_usages))
		for id := range m.credit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedalbums != nil {
		edges = append(edges, user.EdgeAlbums)
	}
	if m.removedmemberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.removedcreated_invite_links != nil {
		edges = append(edges, user.EdgeCreatedInviteLinks)
	}
	if m.removedrevoked_invite_links != nil {
		edges = append(edges, user.EdgeRevokedInviteLinks)
	}
	if m.removedcreated_email_invites != nil {
		edges = append(edges, user.EdgeCreatedEmailInvites)
	}
	if m.removeduploaded_photos != nil {
		edges = append(edges, user.EdgeUploadedPhotos)
	}
	if m.removedthemes != nil {
		edges = append(edges, user.EdgeThemes)
	}
	if m.removedpurchases != nil {
		edges = append(edges, user.EdgePurchases)
	}
	if m.removedcredit_usages != nil {
		edges = append(edges, user.EdgeCreditUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedInviteLinks:
		ids := make([]ent.Value, 0, len(m.removedcreated_invite_links))
		for id := range m.removedcreated_invite_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRevokedInviteLinks:
		ids := make([]ent.Value, 0, len(m.removedrevoked_invite_links))
		for id := range m.removedrevoked_invite_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEmailInvites:
		ids := make([]ent.Value, 0, len(m.removedcreated_email_invites))
		for id := range m.removedcreated_email_invites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUploadedPhotos:
		ids := make([]ent.Value, 0, len(m.removeduploaded_photos))
		for id := range m.removeduploaded_photos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThemes:
		ids := make([]ent.Value, 0, len(m.removedthemes))
		for id := range m.removedthemes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePurchases:
		ids := make([]ent.Value, 0, len(m.removedpurchases))
		for id := range m.removedpurchases {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreditUsages:
		ids := make([]ent.Value, 0, len(m.removedcredit_usages))
		for id := range m.removedcredit_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedalbums {
		edges = append(edges, user.EdgeAlbums)
	}
	if m.clearedmemberships {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.clearedcreated_invite_links {
		edges = append(edges, user.EdgeCreatedInviteLinks)
	}
	if m.clearedrevoked_invite_links {
		edges = append(edges, user.EdgeRevokedInviteLinks)
	}
	if m.clearedcreated_email_invites {
		edges = append(edges, user.EdgeCreatedEmailInvites)
	}
	if m.cleareduploaded_photos {
		edges = append(edges, user.EdgeUploadedPhotos)
	}
	if m.clearedthemes {
		edges = append(edges, user.EdgeThemes)
	}
	if m.clearedpurchases {
		edges = append(edges, user.EdgePurchases)
	}
	if m.clearedcredit_usages {
		edges = append(edges, user.EdgeCreditUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAlbums:
		return m.clearedalbums
	case user.EdgeMemberships:
		return m.clearedmemberships
	case user.EdgeCreatedInviteLinks:
		return m.clearedcreated_invite_links
	case user.EdgeRevokedInviteLinks:
		return m.clearedrevoked_invite_links
	case user.EdgeCreatedEmailInvites:
		return m.clearedcreated_email_invites
	case user.EdgeUploadedPhotos:
		return m.cleareduploaded_photos
	case user.EdgeThemes:
		return m.clearedthemes
	case user.EdgePurchases:
		return m.clearedpurchases
	case user.EdgeCreditUsages:
		return m.clearedcredit_usages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAlbums:
		m.ResetAlbums()
		return nil
	case user.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case user.EdgeCreatedInviteLinks:
		m.ResetCreatedInviteLinks()
		return nil
	case user.EdgeRevokedInviteLinks:
		m.ResetRevokedInviteLinks()
		return nil
	case user.EdgeCreatedEmailInvites:
		m.ResetCreatedEmailInvites()
		return nil
	case user.EdgeUploadedPhotos:
		m.ResetUploadedPhotos()
		return nil
	case user.EdgeThemes:
		m.ResetThemes()
		return nil
	case user.EdgePurchases:
		m.ResetPurchases()
		return nil
	case user.EdgeCreditUsages:
		m.ResetCreditUsages()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
